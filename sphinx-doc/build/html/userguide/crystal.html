

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Creating and Manipulating crystal structures &mdash; Pylada 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="top" title="Pylada 1.0 documentation" href="../index.html" />
    <link rel="up" title="User Guide" href="../userguide.html" />
    <link rel="next" title="Interface to VASP" href="vasp.html" />
    <link rel="prev" title="Testing Pylada" href="testing.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="vasp.html" title="Interface to VASP"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="testing.html" title="Testing Pylada"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Pylada 1.0 documentation</a> &raquo;</li>
          <li><a href="../userguide.html" accesskey="U">User Guide</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="creating-and-manipulating-crystal-structures">
<span id="crystal-ug"></span><h1>Creating and Manipulating crystal structures<a class="headerlink" href="#creating-and-manipulating-crystal-structures" title="Permalink to this headline">¶</a></h1>
<p>A good way to learn is to play with Pylada directly in the python interpreter.
Best of all, use the enhanced shell <a class="reference external" href="http://ipython.org/">ipython</a>. It comes with many goodies. For
instance tab-completion. Or inline help. E.g., once you have typed up the first
example below, try <tt class="docutils literal"><span class="pre">structure.[TAB]</span></tt> and see what it tells you. Then try
<tt class="docutils literal"><span class="pre">structure?</span></tt> to print the description (<a class="reference external" href="http://en.wikipedia.org/wiki/Docstring#Python">docstring</a>) of structure. If setup
right, you can even use it like an ordinary bash shell on <a class="reference external" href="http://ipython.org/ipython-doc/rel-0.12/interactive/tutorial.html#system-shell-commands">pythonic steroids</a>.</p>
<div class="section" id="playing-with-the-crystal-structure">
<h2>Playing with the crystal structure<a class="headerlink" href="#playing-with-the-crystal-structure" title="Permalink to this headline">¶</a></h2>
<div class="section" id="initialization">
<h3>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h3>
<p>To start off, lets create the diamond crystal structure.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylada.crystal</span> <span class="kn">import</span> <span class="n">Structure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span> <span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>     \
<span class="gp">... </span>                         <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>     \
<span class="gp">... </span>                         <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;C&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s">&quot;C&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The first line above imports the <tt class="xref py py-class docutils literal"><span class="pre">Structure</span></tt> class from the
<a class="reference internal" href="../pyapi/crystal.html#module-pylada.crystal" title="pylada.crystal"><tt class="xref py py-mod docutils literal"><span class="pre">crystal</span></tt></a> module.  This class is the basic type which describes
crystal structures in Pylada.  The second and subsequent lines creates diamond.
The unit-cell is initialized within the first parenthesis. It must be given as
a <em>matrix</em>: the cell-vectors are columns (not rows as in many other physics
code). The reason behind choice will soon be apparent when we start playing the
unit-cell directly, entering it into mathematical equations as one would on
paper. At this point, we have a structure empty of any atoms. They can be added
as done above, first inserting the x, y, and z cartesian coordinates and then
the atomic occupation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Cartesian or fractional coordinates? Ask the question no more. Pylada
<em>always</em> expects cartesian coordinates in real space. Period.
However, keep reading to find an instance where the transformation is
done. Just don&#8217;t forget to transform back.</p>
</div>
<p>It is also possible to add whatever attributes directly when initializing the
structure. If one believes in d0 magnetization in carbon substituted by
Technetium, one could add a total moment to the structure, specify an atomic
site for Technetium substitutions, and markup another site with a spin
variable, all in a single one liner.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylada.crystal</span> <span class="kn">import</span> <span class="n">Structure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span> <span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>                         \
<span class="gp">... </span>                         <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>                         \
<span class="gp">... </span>                         <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">moment</span><span class="o">=</span><span class="mi">5</span> <span class="p">)</span> \
<span class="gp">... </span>                     <span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="s">&quot;d0&quot;</span><span class="p">)</span>         \
<span class="gp">... </span>                     <span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="s">&quot;Tc&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note the backslash which tell the python interpreter to read everything as a
single line.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">A number of predefined lattices can be found in
<a class="reference internal" href="../pyapi/crystal/lattices.html#module-pylada.crystal.bravais" title="pylada.crystal.bravais"><tt class="xref py py-mod docutils literal"><span class="pre">bravais</span></tt></a>, <a class="reference internal" href="../pyapi/crystal/lattices.html#module-pylada.crystal.binary" title="pylada.crystal.binary"><tt class="xref py py-mod docutils literal"><span class="pre">binary</span></tt></a>,
<a class="reference internal" href="../pyapi/crystal/lattices.html#module-pylada.crystal.A2BX4" title="pylada.crystal.A2BX4"><tt class="xref py py-mod docutils literal"><span class="pre">A2BX4</span></tt></a>, <a class="reference internal" href="../pyapi/crystal/lattices.html#module-pylada.crystal.ABX" title="pylada.crystal.ABX"><tt class="xref py py-mod docutils literal"><span class="pre">ABX</span></tt></a>. Other similar
modules are always welcomed.</p>
</div>
</div>
<div class="section" id="manipulation">
<h3>Manipulation<a class="headerlink" href="#manipulation" title="Permalink to this headline">¶</a></h3>
<p>So we&#8217;ve got a crystal structure. But how does one go around playing with it?
The cell can be accessed as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">structure</span><span class="o">.</span><span class="n">cell</span>
<span class="go">[ [-0.5, 0.6, 0.5], [0.5, -0.5, 0.5], [0.5, 0.5, -0.5] ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">structure</span><span class="o">.</span><span class="n">cell</span>
<span class="go">[ [-0.5, 0.6, 0.5], [0.1, 0.1, 0.1], [0.5, 0.5, -0.5] ]</span>
</pre></div>
</div>
<p>The first line in the code above accesses the x coordinate of the second cell
vector and changes it to 0.6. The second line of code modifies the y
coordinates of all three cell vectors simultaneously. Note that the cell a
<a class="reference external" href="http://www.numpy.org">numpy</a> array. <a class="reference external" href="http://www.numpy.org">Numpy</a> is python&#8217;s numerical computation package. It does
everything that BLAS or Lapack does, but is much easier to use. And since, when
compiled correctly, it actually uses BLAS or similar library, it can be quite
fast. Most, perhaps all, arrays of numbers in Pylada are <a class="reference external" href="http://www.numpy.org">numpy</a> arrays.</p>
<p>Atoms in the structure can be accessed in the structure as though it were a list:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atom0</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom0</span> <span class="ow">is</span> <span class="n">structure</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Just like any list, the structure can be accessed starting from the end, using
negative integers. It is possible to loop over it as well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">:</span> <span class="k">print</span> <span class="n">atom</span><span class="o">.</span><span class="n">pos</span>
<span class="go">[0 0 0]</span>
<span class="go">[0.25 0.25 0.25]</span>
</pre></div>
</div>
<p>The above loops over all atoms and prints the position of each. Note that the
position is also a <a class="reference external" href="http://www.numpy.org">numpy</a> array. Finally, the structure can be sliced:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s">&#39;Pu&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span> <span class="k">print</span> <span class="n">atom</span><span class="o">.</span><span class="n">type</span>
<span class="go">[&#39;C&#39; &#39;Tc&#39;]</span>
<span class="go">&#39;Pu&#39;</span>
</pre></div>
</div>
<p>The above adds a third atom to the structure. It then proceeds to loop over the
atoms, but skipping the first one. Remember we initialized the second atom with
two species? As such, it is actually a list. The third atom is actually just a
string:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">structure</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">structure</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>You can set the type of an atom to anything you want.
An integer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atom0</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
<span class="go">0</span>
</pre></div>
</div>
<p>A boolean</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atom0</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Or even itself</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atom0</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">atom0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
<span class="go">Atom(0, 0, 0, &#39;C&#39;, spin=&#39;d0&#39;)</span>
</pre></div>
</div>
<p>Though how that would be useful is not clear. The position, however, is
<em>always</em> a <a class="reference external" href="http://www.numpy.org">numpy</a> array. Try otherwise, and you will get an error. Note above
that we set the type using <tt class="docutils literal"><span class="pre">atom0</span></tt> and then print it out using
<tt class="docutils literal"><span class="pre">structure[0]</span></tt>. <tt class="docutils literal"><span class="pre">atom0</span></tt> is a variable created earlier. It references the
structure&#8217;s first atom. You can use one or the other. Both refer to the same
underlying atom.</p>
<p>The attribute <tt class="docutils literal"><span class="pre">spin</span></tt> can be accessed directly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">atom0</span><span class="o">.</span><span class="n">spin</span>
<span class="go">&quot;d0&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom0</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s">&#39;bar&#39;</span>
</pre></div>
</div>
<p>And new attributes can be added easily, whenever the need arises. The same goes
for <tt class="docutils literal"><span class="pre">moment</span></tt> defined in <tt class="docutils literal"><span class="pre">structure</span></tt>&#8216;s initialization. Finally, lets do
some math:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">dot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">inv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inverse_cell</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frac</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">inverse_cell</span><span class="p">,</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
</pre></div>
</div>
<p>The snippet above computes the fractional coordinates of the first atomic
position. <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.inv.html">inv</a> is a <a class="reference external" href="http://www.numpy.org">numpy</a> method to invert 2d-arrays. <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html">dot</a> provides
matrix-matrix multiplication and matrix-vector multiplications, and
vector-vector inner products.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Why use <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html">dot</a>? By default, <tt class="docutils literal"><span class="pre">vectorA</span> <span class="pre">*</span> <span class="pre">vectorB</span></tt> multiplies arrays
element per element in <a class="reference external" href="http://www.numpy.org">numpy</a>. There does exist a class called
Matrix which will change the behavior to actual matrix
mutliplication. But to avoid any surprises, Pylada uses the default.
And hence makes use of <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html">dot</a>.</p>
</div>
</div>
<div class="section" id="specifiying-units">
<h3>Specifiying units<a class="headerlink" href="#specifiying-units" title="Permalink to this headline">¶</a></h3>
<p>The units are given using the structure&#8217;s scale attribute:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">quantities</span> <span class="kn">import</span> <span class="n">nanometer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">nanometer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">structure</span><span class="o">.</span><span class="n">scale</span>
<span class="go">5</span>
</pre></div>
</div>
<p>The package <a class="reference external" href="http://packages.python.org/quantities/index.html">quantities</a> allows us to specify units explicitly. Note however
that the scale is converted to angstroms. Units are arbitrary and an arbitrary
choice was made to use angstroms throughout Pylada. <a class="reference external" href="http://packages.python.org/quantities/index.html">quantities</a> makes it
possible to convert back and forth between other preferred unit systems.
In other words, the unit-cell <tt class="docutils literal"><span class="pre">structure.scale</span> <span class="pre">*</span> <span class="pre">structure.cell</span></tt> is in
angstrom once multiplied by the scale. And so are the atomic positions
<tt class="docutils literal"><span class="pre">structure.scale</span> <span class="pre">*</span> <span class="pre">structure[0].pos</span></tt>.</p>
</div>
</div>
<div class="section" id="more-advanced-structure-manipulation-methods">
<h2>More advanced structure manipulation methods<a class="headerlink" href="#more-advanced-structure-manipulation-methods" title="Permalink to this headline">¶</a></h2>
<div class="section" id="supercells-and-primitive-unit-cells">
<h3>Supercells and primitive unit cells<a class="headerlink" href="#supercells-and-primitive-unit-cells" title="Permalink to this headline">¶</a></h3>
<p>Quite often, one needs to a supercell, i.e. a multiple, of a smaller unit cell.
Doing this takes all of a single line.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylada.crystal</span> <span class="kn">import</span> <span class="n">Structure</span><span class="p">,</span> <span class="n">supercell</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># First create unit cell.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span> <span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>                  \
<span class="gp">... </span>                         <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>                  \
<span class="gp">... </span>                         <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span>               \
<span class="gp">... </span>                     <span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;C&quot;</span><span class="p">)</span>             \
<span class="gp">... </span>                     <span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s">&quot;C&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Now create conventional cell.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conventional</span> <span class="o">=</span> <span class="n">supercell</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">structure</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conventional</span>
<span class="go">Structure( 1, 0, 0,\</span>
<span class="go">           0, 1, 0,\</span>
<span class="go">           0, 0, 1, scale=1.0 )\</span>
<span class="go">  .add_atom(0, 0, 0, &#39;C&#39;)\</span>
<span class="go">  .add_atom(0.25, 0.25, 0.25, &#39;C&#39;) )\</span>
<span class="go">  .add_atom(0, 0, 0, &#39;C&#39;, site=0)\</span>
<span class="go">  .add_atom(0.25, 0.25, 0.25, &#39;C&#39;, site=1)\</span>
<span class="go">  .add_atom(0.5, 0, 0.5, &#39;C&#39;, site=0)\</span>
<span class="go">  .add_atom(0.75, 0.25, 0.75, &#39;C&#39;, site=1)\</span>
<span class="go">  .add_atom(0.5, 0.5, 0, &#39;C&#39;, site=0)\</span>
<span class="go">  .add_atom(0.75, 0.75, 0.25, &#39;C&#39;, site=1)\</span>
<span class="go">  .add_atom(0, 0.5, 0.5, &#39;C&#39;, site=0)\</span>
<span class="go">  .add_atom(0.25, 0.75, 0.75, &#39;C&#39;, site=1)</span>
</pre></div>
</div>
<p>The above creates the conventional cell from the diamond unit cell. Note that
the new cell is given in cartesian coordinates (and in the units of the original
unit structure). Using <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html">dot</a> and <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.inv.html">inv</a>, one could of course specify the
conventional cell in fractional coordinates:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">conventional</span> <span class="o">=</span> <span class="n">supercell</span><span class="p">(</span> <span class="n">dot</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">inv</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">cell</span><span class="p">)),</span> <span class="n">structure</span><span class="p">)</span>
</pre></div>
</div>
<p>It is just a bit more verbose.</p>
<p>Once a supercell is obtained, it is possible to go back to the original primitive unit-cell.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylada.crystal</span> <span class="kn">import</span> <span class="n">primitive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">primitive</span><span class="p">(</span><span class="n">conventional</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span>
<span class="go">Structure( 0.5, 0.5, 0,\</span>
<span class="go">           0, 0.5, 0.5,\</span>
<span class="go">           0.5, 0, 0.5,\</span>
<span class="go">           scale=1 )\</span>
<span class="go">  .add_atom(0, 0, 0, &#39;C&#39;)\</span>
<span class="go">  .add_atom(0.25, 0.25, 0.25, &#39;C&#39;)</span>
</pre></div>
</div>
<p>Note however that this method is far from perfect and is likely not robust with
respect to numerical noise. The optional <tt class="docutils literal"><span class="pre">tolerance</span></tt> keyword argument may
help to some degree. It defaults to 1e-8. There is also a method to check
whether a structure is indeed primitive.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylada.crystal</span> <span class="kn">import</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">is_primitive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_primitive</span><span class="p">(</span><span class="n">conventional</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_primitive</span><span class="p">(</span><span class="n">primitive</span><span class="p">(</span><span class="n">conventional</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It is also possible to obtain the cyclic groups of a supercell with respect to
its backbone lattice. In practice, it gives us a way to label an atom with
respect to the group of periodic images it belongs to <a class="reference internal" href="#hf">[HF]</a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span><span class="p">,</span> <span class="nb">all</span><span class="p">,</span> <span class="nb">abs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylada.crystal</span> <span class="kn">import</span> <span class="n">SmithTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># create smith transform.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span> <span class="o">=</span> <span class="n">SmithTransform</span><span class="p">(</span><span class="n">conventional</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># loop over random periodic images</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="c"># create a vector with respect to its corresponding lattice site.</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">pos</span>  <span class="o">=</span> <span class="n">conventional</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">lattice</span><span class="p">[</span> <span class="n">conventional</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">site</span> <span class="p">]</span><span class="o">.</span><span class="n">pos</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="c">#</span>
<span class="go">&gt;&gt;&gt;&gt;  # random periodic image</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">translation</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&quot;float64&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">pos</span> <span class="o">+=</span> <span class="n">dot</span><span class="p">(</span><span class="n">conventional</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">translation</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="c"># get indices in cyclic group.</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">indices</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="c"># yep, its the same as the original atom.</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">indices</span> <span class="o">-</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>We check that statement in the code above. An atomic site is shifted to random
periodic images. Yet its cyclic indices remain the same. Note that Diamond has
two sublattices. This means it has two cyclic group <a class="reference internal" href="#hf2">[HF2]</a>, one for each atomic site
in the lattice. This is why the input to <tt class="xref py py-func docutils literal"><span class="pre">indices</span></tt> is a vector which has been
translated back to the origin of its sublattice. We use the <tt class="docutils literal"><span class="pre">site</span></tt> attribute
added to each atom by <tt class="xref py py-func docutils literal"><span class="pre">supercell()</span></tt> to make the translation. This
attribute can also be set using the <tt class="xref py py-func docutils literal"><span class="pre">map_sites()</span></tt> method.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">supercell()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">primitive()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">map_sites()</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">is_primitive()</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">SmithTransform</span></tt></p>
</div>
</div>
<div class="section" id="space-group-operations">
<h3>Space-group operations<a class="headerlink" href="#space-group-operations" title="Permalink to this headline">¶</a></h3>
<p>The space group operations of a structure can also easily be obtained. This is
the operations, not the name of the space group. The return is a list of 4x3
<a class="reference external" href="http://www.numpy.org">numpy</a> arrays where the upper 3x3 block is a rotation and the lowest row is a
translation. The translation should be applied <em>after</em> the rotation. Going back
to the original diamond structure:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sg</span> <span class="o">=</span> <span class="n">space_group</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sg</span> <span class="o">==</span> <span class="n">space_group</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([[ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.],</span>
<span class="go">       [ 0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># applying the operation:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">dot</span><span class="p">,</span> <span class="n">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dot</span><span class="p">(</span><span class="n">sg</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="mi">3</span><span class="p">],</span> <span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="n">sg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([ 1., -1.,  0.])</span>
</pre></div>
</div>
<p>A structure can easily be transform according to any affine transformation defined the same way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylada.crystal</span> <span class="kn">import</span> <span class="n">transform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transform</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">sg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">Structure( 0, 0.5, 0.5,\</span>
<span class="go">           -0.5, 0, -0.5,\</span>
<span class="go">           -0.5, -0.5, 0,\</span>
<span class="go">           scale=1 )\</span>
<span class="go">  .add_atom(0, 0, 0, &#39;C&#39;)\</span>
<span class="go">  .add_atom(0.25, -0.25, -0.25, &#39;C&#39;)</span>
</pre></div>
</div>
<p>Of course, in this case the result is nothing more than a different
parameterization of the same lattice.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">space_group()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">transform()</span></tt></p>
</div>
</div>
<div class="section" id="neighbors-and-coordination-shells">
<h3>Neighbors and Coordination Shells<a class="headerlink" href="#neighbors-and-coordination-shells" title="Permalink to this headline">¶</a></h3>
<p>A list of first neighbors can be obtained for any point in the structure.
Still using the diamond structure.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylada.crystal</span> <span class="kn">import</span> <span class="n">neighbors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.125</span><span class="p">,</span><span class="mf">0.125</span><span class="p">,</span> <span class="mf">0.125</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">8</span>
</pre></div>
</div>
<p>The first argument of <tt class="docutils literal"><span class="pre">neighbors</span></tt> is the structure, the second is the number
of neighbors to look for, and the third is the position for which to look for
neighbors. Note that 5 neighbors are requested, but 8 are actually returned.
The method always makes sure to return a complete coordination shell.
Coordinations are judged according to the distance from the central point. An
optional <tt class="docutils literal"><span class="pre">tolerance</span></tt> keyword argument exists defining how <em>equal</em> distances
are judged.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(Atom(0, 0, 0, &#39;C&#39;), array([-0.125, -0.125, -0.125]), 0.21650635094610965)</span>
</pre></div>
</div>
<p>Each item in the list returned by neighbor is a tuple consisting of reference
to the neighboring atom, a vector going from the central point to relevant
periodic image of that atom, and the distance from the center to the periodic
image. Additionally, a <tt class="docutils literal"><span class="pre">coordination_shells</span></tt> method exists which returns a
list of lists of neighbour, where each inner list is a single coordination
shell.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylada.crystal</span> <span class="kn">import</span> <span class="n">coordination_shell</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span> <span class="n">coordination_shell</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.125</span><span class="p">,</span> <span class="mf">0.125</span><span class="p">,</span> <span class="mf">0.125</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span> <span class="n">coordination_shell</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.125</span><span class="p">,</span> <span class="mf">0.125</span><span class="p">,</span> <span class="mf">0.125</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">neighbors()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">coordination_shells()</span></tt></p>
</div>
</div>
<div class="section" id="input-output-saving-to-a-file-sending-as-mpi-message">
<h3>Input, output, saving to a file, sending as MPI message<a class="headerlink" href="#input-output-saving-to-a-file-sending-as-mpi-message" title="Permalink to this headline">¶</a></h3>
<p>It is of course possible to save a structure to file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;text&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span> <span class="nb">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
</pre></div>
</div>
<p>And do to read it out.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;text&#39;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span> <span class="n">structure</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
</pre></div>
</div>
<p>Note that structures and atoms are printed out as strings which can be executed
to retrieve the actual python object (i.e. it is <a class="reference external" href="http://docs.python.org/library/functions.html#repr">representation</a>). The only
caveat is that the attributes you have added to the structure must also be
representable.</p>
<p>Structures and atoms can be pickled. <a class="reference external" href="http://docs.python.org/library/pickle.html">pickle</a> is a python module for data
retention. It transforms objects into a stream of characters which can be saved
to disk, sent as MPI messages, or whatever suits your fancy, and then
reinterpreted to become the same python objects all over again.
As far as MPI is concerned, however, the best bet is to use <a class="reference external" href="http://www.boost.org/doc/libs/1_35_0/doc/html/mpi/python.html">boost.mpi</a>. This
is a great python wrapper around the original MPI specifications. It truly makes
MPI easy.</p>
</div>
<div class="section" id="conclusion">
<h3>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h3>
<p>Pylada makes it easy to manipulate crystal structures any way you fancy. Further
methods exist beyond those described here. There is a method to create periodic
divide and conquer boxes, very practical when dealing with truly large
structures. There is a method to transform structures into lattice agnostic
representations, and others still to iterate over equivalent lattice sites,
atoms of nanowire shells. How the latter method was implemented is given as a
more advanced example below. Peek at it, and you will see how a fairly complex
functionality can be designed with only a few lines of codes. For the others,
however, please to the code itself, or to the API documentation.</p>
</div>
</div>
<div class="section" id="example-iterating-over-the-shells-of-a-core-shell-nanowire">
<h2>Example: Iterating over the shells of a core-shell nanowire<a class="headerlink" href="#example-iterating-over-the-shells-of-a-core-shell-nanowire" title="Permalink to this headline">¶</a></h2>
<p>Core shell nanowires are nano-structures where a thin nanowire of, say,
germanium, is coated with alternating layers of silicon and germanium. I will
now show how a few lines of code creates all the building blocks needed to look
at any possible arrangement of core-shells. This particular piece of code was
used to optimize light absorption at the band edges of Si/Ge core-shell
nanowires <a class="reference internal" href="#zalz">[ZALZ]</a>.</p>
<p>The point here is to create an <a class="reference external" href="http://docs.python.org/tutorial/classes.html#generators">generator</a> which will allow us to iterate over
shells in an outer loop and atoms (within the shell) in an inner loop. For
instance, if we wanted to alternate Si and Ge layers.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylada.crystal</span> <span class="kn">import</span> <span class="n">shell_iterator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">shell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shell_iterator</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])):</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">shell</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span> <span class="n">atom</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&#39;Hg&#39;</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="k">elif</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">atom</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&#39;Si&#39;</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="k">elif</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">atom</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&#39;Ge&#39;</span>
</pre></div>
</div>
<p>The nanowire is created within a structure. In this case, it is likely a fairly
large supercell of zinc blende. Within it we want to place a nanowire with
given growth direction and a given center (the center can be on an atom, on a
bond, or somewhere else). The nanowire consists of 10 alternating layers of Si
and Ge, capped by a fake atom (in this case Hg). It is constructed using two
nested loops. The outer loop runs over shells, and the inner loop over atoms in
a shell. The <a class="reference external" href="http://docs.python.org/library/functions.html?highlight=enumerate#enumerate">enumerate</a> method is a python primitive which counts the number
of iterations in a loop. It conveniently keeps track of which shell we are in,
so that we can alternate Si and Ge.</p>
<p>Now follows the code for the shell <a class="reference external" href="http://docs.python.org/tutorial/classes.html#generators">generator</a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shell_iterator</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="s">&quot;&quot;&quot; Iterates over cylindrical shells of atoms.</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="n">It</span> <span class="n">allows</span> <span class="n">to</span> <span class="n">rapidly</span> <span class="n">create</span> <span class="n">core</span><span class="o">-</span><span class="n">shell</span> <span class="n">nanowires</span><span class="o">.</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="p">:</span><span class="n">Parameters</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">structure</span> <span class="p">:</span> <span class="p">:</span><span class="n">class</span><span class="p">:</span><span class="sb">`pylada.crystal.Structure`</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="n">Structure</span> <span class="ow">or</span> <span class="n">Lattice</span> <span class="n">over</span> <span class="n">which</span> <span class="n">to</span> <span class="n">iterate</span><span class="o">.</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">center</span> <span class="p">:</span> <span class="mi">3</span><span class="n">d</span> <span class="n">vector</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="n">Growth</span> <span class="n">direction</span> <span class="n">of</span> <span class="n">the</span> <span class="n">nanowire</span><span class="o">.</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">thickness</span> <span class="p">:</span> <span class="nb">float</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="n">Thickness</span> <span class="ow">in</span> <span class="n">units</span> <span class="n">of</span> <span class="sb">``</span><span class="n">structure</span><span class="o">.</span><span class="n">scale</span><span class="sb">``</span> <span class="n">of</span> <span class="n">an</span> <span class="n">individual</span> <span class="n">shell</span><span class="o">.</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="p">:</span><span class="n">returns</span><span class="p">:</span> <span class="n">Yields</span> <span class="n">iterators</span> <span class="n">over</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">single</span> <span class="n">shell</span><span class="o">.</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="s">&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">  from operator import itemgetter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">  from numpy import array, dot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">  from numpy.linalg import norm</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">direction</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">direction</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span> <span class="k">yield</span> <span class="n">structure</span><span class="p">;</span> <span class="k">return</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="c"># orders position with respect to cylindrical coordinate.</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">positions</span> <span class="o">=</span> <span class="n">into_voronoi</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">center</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">]),</span> <span class="n">structure</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">projs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">norm</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span><span class="o">*</span><span class="n">direction</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">positions</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">projs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">projs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="c"># creates classes of positions.</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">proj</span> <span class="ow">in</span> <span class="n">projs</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">proj</span><span class="o">/</span><span class="n">thickness</span><span class="o">+</span><span class="mf">1e-12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">else</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">def</span> <span class="nf">inner_layer_iterator</span><span class="p">():</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="sd">&quot;&quot;&quot; Iterates over atoms in a single layer. &quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">layer</span><span class="p">:</span> <span class="k">yield</span> <span class="n">structure</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">yield</span> <span class="n">inner_layer_iterator</span><span class="p">()</span>
</pre></div>
</div>
<p>As you can see, about a third of the code is comments.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span>  <span class="n">direction</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">direction</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span> <span class="k">yield</span> <span class="n">structure</span><span class="p">;</span> <span class="k">return</span>
</pre></div>
</div>
<p>The first line makes sure that the direction is normalized and is a <a class="reference external" href="http://www.numpy.org">numpy</a>
array. The second makes sure the structure is not too absurd.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span>  <span class="c"># orders position with respect to cylindrical coordinate.</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">positions</span> <span class="o">=</span> <span class="n">into_voronoi</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">center</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">]),</span> <span class="n">structure</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">projs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">norm</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span><span class="o">*</span><span class="n">direction</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">positions</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">projs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">projs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>The crux are the three lines of code above. Basically, we want to transform the
atoms from cartesian to cylindrical coordinates. However, there is a trick. The
structure is periodic and we have first to make sure that we are looking at the
periodic images which are closest to the center. That is the function of the
<tt class="docutils literal"><span class="pre">into_voronoi</span></tt> method. It takes a vector (or array of vectors) and a cell
matrix, and folds the former into the Wigner-Seitz cell (aka first brillouin
zone, aka first Voronoi region of <tt class="docutils literal"><span class="pre">center</span></tt>). The second line creates a list
of tuples, where the first item is an index into the structure, and the second
item is the cylindrical coordinate <tt class="docutils literal"><span class="pre">r</span></tt>. Now, all we need do is sort the list
with respect to <tt class="docutils literal"><span class="pre">r</span></tt>. This is the third line. <a class="reference external" href="http://docs.python.org/library/operator.html#operator.__getitem__">getitem</a> tells python to sort
with respect to the second item in each tuple.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Technically, we should rather find the periodic image with the
smallest <tt class="docutils literal"><span class="pre">r</span></tt> component. However, since the supercell is (generally)
much smaller in the <tt class="docutils literal"><span class="pre">z</span></tt> direction, it has yet never mattered.</p>
</div>
<p>We now have a sorted list of cylindrical coordinates to which are attached the
index of each corresponding atom in the structure. At this point, we need to
create a mapping from the index of the shell to the relevant items in the list
we just created. Note that the thickness of the shell is actually an external
parameter.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span>  <span class="c"># creates classes of positions.</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">projs</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="o">/</span><span class="n">thickness</span><span class="o">+</span><span class="mf">1e-12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">else</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>Finally, the rest of the code is concerned with making the outer and inner
loops possible.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="k">def</span> <span class="nf">inner_layer_iterator</span><span class="p">():</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="sd">&quot;&quot;&quot; Iterates over atoms in a single layer. &quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">layer</span><span class="p">:</span> <span class="k">yield</span> <span class="n">structure</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="k">yield</span> <span class="n">inner_layer_iterator</span><span class="p">()</span>
</pre></div>
</div>
<p>We loop over the (sorted) keys in the mapping just created. Each iteration
visits a different shell, starting with the innermost. For each, we <a class="reference external" href="http://docs.python.org/tutorial/classes.html#generators">yield</a> a
<a class="reference external" href="http://docs.python.org/tutorial/classes.html#generators">generator</a> which will loop over the atoms in the shell. To yield means we
return <em>temporarily</em> from <tt class="docutils literal"><span class="pre">shell_iterator</span></tt>. However, the next time the user
asks to loop to the next shell, the python interpreter knows to reenter
<tt class="docutils literal"><span class="pre">shell_iterator</span></tt> <em>right after the yield statement</em>, as though it had never
left.  I strongly recommend taking a closer look at this <a class="reference external" href="http://docs.python.org/tutorial/classes.html#generators">yield</a> deal.
Programming is often about doing loops and <a class="reference external" href="http://docs.python.org/tutorial/classes.html#generators">yield</a>, once you&#8217;ve warped your
brain around the concept, makes it extremely easy.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-class docutils literal"><span class="pre">shell_iterator</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">layer_iterator</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">equivalence_iterator</span></tt></p>
</div>
<table class="docutils citation" frame="void" id="hf" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[HF]</a></td><td>Gus L. Hart, Rodney W. Forcade,
<cite>Algorithm for generating derivative structures</cite>,
Phys. Rev. B <strong>77</strong>, 224115 (2008),
<a class="reference external" href="http://dx.doi.org/10.1103/PhysRevB.77.224115">http://dx.doi.org/10.1103/PhysRevB.77.224115</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="hf2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[HF2]</a></td><td>Gus L. Hart, Rodney W. Forcade,
<cite>Generating derivative structures from multilattices: Algorithm and
application to hcp alloys</cite>,
Phys. Rev. B <strong>80</strong>, 014120 (2009),
<a class="reference external" href="http://dx.doi.org/10.1103/PhysRevB.80.014120">http://dx.doi.org/10.1103/PhysRevB.80.014120</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="zalz" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[ZALZ]</a></td><td>Lijun Zhang, Mayeul d&#8217;Avezac, Jun-Wei Luo, Alex Zunger
<cite>Genomic Design of Strong Direct-Gap Optical Transition in Si/Ge
Core/Multishell Nanowires</cite>,
Nano Lett. <strong>12</strong>, 984-991 (2012),
<a class="reference external" href="http://dx.doi.org/10.1021/nl2040892">http://dx.doi.org/10.1021/nl2040892</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Creating and Manipulating crystal structures</a><ul>
<li><a class="reference internal" href="#playing-with-the-crystal-structure">Playing with the crystal structure</a><ul>
<li><a class="reference internal" href="#initialization">Initialization</a></li>
<li><a class="reference internal" href="#manipulation">Manipulation</a></li>
<li><a class="reference internal" href="#specifiying-units">Specifiying units</a></li>
</ul>
</li>
<li><a class="reference internal" href="#more-advanced-structure-manipulation-methods">More advanced structure manipulation methods</a><ul>
<li><a class="reference internal" href="#supercells-and-primitive-unit-cells">Supercells and primitive unit cells</a></li>
<li><a class="reference internal" href="#space-group-operations">Space-group operations</a></li>
<li><a class="reference internal" href="#neighbors-and-coordination-shells">Neighbors and Coordination Shells</a></li>
<li><a class="reference internal" href="#input-output-saving-to-a-file-sending-as-mpi-message">Input, output, saving to a file, sending as MPI message</a></li>
<li><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-iterating-over-the-shells-of-a-core-shell-nanowire">Example: Iterating over the shells of a core-shell nanowire</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="testing.html"
                        title="previous chapter">Testing Pylada</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="vasp.html"
                        title="next chapter">Interface to VASP</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/userguide/crystal.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="vasp.html" title="Interface to VASP"
             >next</a> |</li>
        <li class="right" >
          <a href="testing.html" title="Testing Pylada"
             >previous</a> |</li>
        <li><a href="../index.html">Pylada 1.0 documentation</a> &raquo;</li>
          <li><a href="../userguide.html" >User Guide</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Mayeul d&#39;Avezac.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>