

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nrelmat.ScanXml &mdash; Pylada-light 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="top" title="Pylada-light 1.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Pylada-light 1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for nrelmat.ScanXml</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/env python</span>
<span class="c"># Copyright 2013 National Renewable Energy Laboratory, Golden CO, USA</span>
<span class="c"># This file is part of NREL MatDB.</span>
<span class="c">#</span>
<span class="c"># NREL MatDB is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the GNU General Public License as published by</span>
<span class="c"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"># (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># NREL MatDB is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU General Public License</span>
<span class="c"># along with NREL MatDB.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>


<span class="kn">import</span> <span class="nn">datetime</span><span class="o">,</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">traceback</span><span class="o">,</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">xml.etree.cElementTree</span> <span class="kn">as</span> <span class="nn">etree</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span> <span class="nb">all</span><span class="o">=</span><span class="s">&#39;raise&#39;</span><span class="p">,</span> <span class="n">under</span><span class="o">=</span><span class="s">&#39;ignore&#39;</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">readVasp</span>


<span class="c">#====================================================================</span>

<span class="k">def</span> <span class="nf">badparms</span><span class="p">(</span> <span class="n">msg</span><span class="p">):</span>
  <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Error: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">msg</span><span class="p">,)</span>
  <span class="k">print</span> <span class="s">&#39;Parms:&#39;</span>
  <span class="k">print</span> <span class="s">&#39;  -bugLev    &lt;int&gt;      debug level&#39;</span>
  <span class="k">print</span> <span class="s">&#39;  -inFile    &lt;string&gt;   input file&#39;</span>
  <span class="k">print</span> <span class="s">&#39;  -maxLev    &lt;int&gt;      max xml print level&#39;</span>
  <span class="k">print</span> <span class="s">&#39;&#39;</span>
  <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c">#====================================================================</span>

<div class="viewcode-block" id="main"><a class="viewcode-back" href="../../nrelmatdb/ScanXml.html#nrelmat.ScanXml.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Test driver: Extracts info from a VASP vasprun.xml file.</span>

<span class="sd">  Command line parameters:</span>

<span class="sd">  ================  =========    ==============================================</span>
<span class="sd">  Parameter         Type         Description</span>
<span class="sd">  ================  =========    ==============================================</span>
<span class="sd">  **-bugLev**       integer      Debug level.  Normally 0.</span>
<span class="sd">  **-inFile**       string       Input file</span>
<span class="sd">  **-maxLev**       int          max xml print level</span>
<span class="sd">  ================  =========    ==============================================</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">bugLev</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">inFile</span> <span class="o">=</span> <span class="bp">None</span>
  <span class="n">maxLev</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">badparms</span><span class="p">(</span><span class="s">&#39;Parms must be key/value pairs&#39;</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">iarg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="n">iarg</span><span class="p">]</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="n">iarg</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s">&#39;-bugLev&#39;</span><span class="p">:</span> <span class="n">bugLev</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s">&#39;-inFile&#39;</span><span class="p">:</span> <span class="n">inFile</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s">&#39;-maxLev&#39;</span><span class="p">:</span> <span class="n">maxLev</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">badparms</span><span class="p">(</span><span class="s">&#39;unknown key: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,))</span>

  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="n">badparms</span><span class="p">(</span><span class="s">&#39;parm not specified: -bugLev&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">inFile</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="n">badparms</span><span class="p">(</span><span class="s">&#39;parm not specified: -inFile&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">maxLev</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="n">badparms</span><span class="p">(</span><span class="s">&#39;parm not specified: -maxLev&#39;</span><span class="p">)</span>

  <span class="n">resObj</span> <span class="o">=</span> <span class="n">ResClass</span><span class="p">()</span>
  <span class="n">parseXml</span><span class="p">(</span> <span class="n">bugLev</span><span class="p">,</span> <span class="n">inFile</span><span class="p">,</span> <span class="n">maxLev</span><span class="p">,</span> <span class="n">resObj</span><span class="p">)</span>


<span class="c">#====================================================================</span>
<span class="c">#====================================================================</span>
</div>
<div class="viewcode-block" id="ResClass"><a class="viewcode-back" href="../../nrelmatdb/ScanXml.html#nrelmat.ScanXml.ResClass">[docs]</a><span class="k">class</span> <span class="nc">ResClass</span><span class="p">:</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  An empty class used as a data container for results.</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">keys</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
      <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
      <span class="n">stg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span> <span class="n">val</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">stg</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">sep</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
      <span class="k">else</span><span class="p">:</span> <span class="n">sep</span> <span class="o">=</span> <span class="s">&#39; &#39;</span>
      <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;  </span><span class="si">%s</span><span class="s">:  type: </span><span class="si">%s</span><span class="s">  val:</span><span class="si">%s%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">sep</span><span class="p">,</span> <span class="n">val</span><span class="p">,)</span>
    <span class="k">return</span> <span class="n">msg</span>

<span class="c">#====================================================================</span>
<span class="c">#====================================================================</span>


<span class="c"># Fills resObj.</span>
</div>
<div class="viewcode-block" id="parseXml"><a class="viewcode-back" href="../../nrelmatdb/ScanXml.html#nrelmat.ScanXml.parseXml">[docs]</a><span class="k">def</span> <span class="nf">parseXml</span><span class="p">(</span> <span class="n">bugLev</span><span class="p">,</span> <span class="n">inFile</span><span class="p">,</span> <span class="n">maxLev</span><span class="p">,</span> <span class="n">resObj</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Extracts info from the vasprun.xml file from a VASP run,</span>
<span class="sd">  using the Python xml.etree.cElementTree API.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * bugLev (int): Debug level.  Normally 0.</span>
<span class="sd">  * inFile (str): Path of the input vasprun.xml file.</span>
<span class="sd">  * resObj (class ResClass): data object: we set attributes here.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * None</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="k">try</span><span class="p">:</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span> <span class="n">inFile</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span>
    <span class="n">throwerr</span><span class="p">((</span><span class="s">&#39;parseXml: invalid xml in file: &quot;</span><span class="si">%s</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&#39;</span>
      <span class="o">+</span> <span class="s">&#39;  Msg: </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">inFile</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">exc</span><span class="p">),))</span>

  <span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span> <span class="n">printNode</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxLev</span><span class="p">)</span>      <span class="c"># node, curLev, maxLev</span>

  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== program, version, date etc =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># xxx program, version, subversion, etc</span>

  <span class="c"># PyLada: vasp/extract/base.py: datetime()</span>
  <span class="c"># OUTCAR: use the 1 occurance of:</span>
  <span class="c">#   executed on             LinuxIFC date 2013.03.11  09:32:24</span>
  <span class="n">dtStg</span> <span class="o">=</span> <span class="n">getString</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;generator/i[@name=</span><span class="se">\&#39;</span><span class="s">date</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="n">tmStg</span> <span class="o">=</span> <span class="n">getString</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;generator/i[@name=</span><span class="se">\&#39;</span><span class="s">time</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="n">dateFmtIn</span> <span class="o">=</span> <span class="s">&#39;%Y %m </span><span class="si">%d</span><span class="s"> %H:%M:%S&#39;</span>
  <span class="n">dateFmtOut</span> <span class="o">=</span> <span class="s">&#39;%Y-%m-</span><span class="si">%d</span><span class="s"> %H:%M:%S&#39;</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">runDate</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span>
    <span class="s">&#39;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dtStg</span><span class="p">,</span> <span class="n">tmStg</span><span class="p">),</span> <span class="n">dateFmtIn</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;runDate: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">runDate</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span> <span class="n">dateFmtOut</span><span class="p">),)</span>


  <span class="c"># iterTimes</span>
  <span class="c"># Each node is has cpuTime, wallTime:</span>
  <span class="c">#       &lt;time name=&#39;totalsc&#39;&gt;22.49 24.43&lt;/time&gt;</span>
  <span class="n">nodes</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;calculation/time[@name=</span><span class="se">\&#39;</span><span class="s">totalsc</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="n">iterCpuTimes</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">iterRealTimes</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">text</span>
    <span class="n">toks</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">toks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="c"># Kluge: sometimes the two time fields run together:</span>
      <span class="c">#     &lt;time name=&quot;totalsc&quot;&gt;18560.1718566.89&lt;/time&gt;</span>
      <span class="c"># should be:</span>
      <span class="c">#     &lt;time name=&quot;totalsc&quot;&gt;18560.17 18566.89&lt;/time&gt;</span>
      <span class="c"># In this case, try to split it,</span>
      <span class="c"># or just use the first time for both values.</span>
      <span class="n">tok</span> <span class="o">=</span> <span class="n">toks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">ix</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;invalid times: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">node</span><span class="p">),))</span>
      <span class="n">iy</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">iy</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">iy</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;invalid times: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">node</span><span class="p">),))</span>
      <span class="n">tmStga</span> <span class="o">=</span> <span class="n">tok</span><span class="p">[:</span><span class="n">ix</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span>
      <span class="n">tmStgb</span> <span class="o">=</span> <span class="n">tok</span><span class="p">[</span><span class="n">ix</span><span class="o">+</span><span class="mi">3</span><span class="p">:]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">toks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">tmStga</span> <span class="o">=</span> <span class="n">toks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">tmStgb</span> <span class="o">=</span> <span class="n">toks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;invalid times: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">node</span><span class="p">),))</span>
    <span class="n">iterCpuTimes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="nb">float</span><span class="p">(</span> <span class="n">tmStga</span><span class="p">))</span>
    <span class="n">iterRealTimes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="nb">float</span><span class="p">(</span> <span class="n">tmStgb</span><span class="p">))</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">iterCpuTimes</span> <span class="o">=</span> <span class="n">iterCpuTimes</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">iterRealTimes</span> <span class="o">=</span> <span class="n">iterRealTimes</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;iterCpuTimes: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">iterCpuTimes</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;iterRealTimes: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">iterRealTimes</span><span class="p">,)</span>


  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== incar parameters =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># algo</span>
  <span class="c"># PyLada: vasp/extract/base.py: algo()</span>
  <span class="c"># OUTCAR: use the 1 occurance of:</span>
  <span class="c">#   ALGO = Fast</span>
  <span class="n">algoPath</span> <span class="o">=</span> <span class="s">&#39;incar/i[@name=</span><span class="se">\&#39;</span><span class="s">ALGO</span><span class="se">\&#39;</span><span class="s">]&#39;</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span> <span class="n">algoPath</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">algo</span> <span class="o">=</span> <span class="s">&#39;n/a&#39;</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">algo</span> <span class="o">=</span> <span class="n">getString</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">algoPath</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;algo: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">algo</span><span class="p">,)</span>

  <span class="c"># encut</span>
  <span class="c"># PyLada: vasp/extract/base.py: encut()</span>
  <span class="c"># OUTCAR: use the first occurance of:</span>
  <span class="c">#   ENCUT  =  252.0 eV  18.52 Ry    4.30 a.u.   4.08  4.08 15.92*2*pi/ulx,y,z</span>
  <span class="c">#   ENCUT = 252.0</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">encut_ev</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;incar/i[@name=</span><span class="se">\&#39;</span><span class="s">ENCUT</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;encut_ev: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">encut_ev</span><span class="p">,)</span>

  <span class="c"># ldauType</span>
  <span class="c"># PyLada: vasp/extract/base.py: LDAUType()</span>
  <span class="c"># OUTCAR: use the first occurance of:</span>
  <span class="c">#   LDA+U is selected, type is set to LDAUTYPE =  2</span>
  <span class="c">#   LDAUTYPE = 2</span>
  <span class="c">#rawLdauType = getScalar( root, &#39;incar/v[@name=\&#39;LDAUTYPE\&#39;]&#39;, int)</span>
  <span class="c">#if rawLdauType == 1: resObj.ldauType = &#39;liechtenstein&#39;</span>
  <span class="c">#elif rawLdauType == 2: resObj.ldauType = &#39;dudarev&#39;</span>
  <span class="c">#else: throwerr(&#39;unknown rawLdauType: %d&#39; % (rawLdauType,))</span>
  <span class="c">#if bugLev &gt;= 5:</span>
  <span class="c">#  print &#39;rawLdauType: %d  ldauType: %s&#39; % (rawLdauType, resObj.ldauType,)</span>

  <span class="n">tstg</span> <span class="o">=</span> <span class="n">getString</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;incar/i[@name=</span><span class="se">\&#39;</span><span class="s">SYSTEM</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">systemName</span> <span class="o">=</span> <span class="n">tstg</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\&#39;</span><span class="s">&quot;&#39;</span><span class="p">)</span>   <span class="c"># get rid of extraneous quotes</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;systemName: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">systemName</span><span class="p">,)</span>



  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== general parameters =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">generalName</span> <span class="o">=</span> <span class="n">getString</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span> <span class="s">&#39;parameters/separator[@name=</span><span class="se">\&#39;</span><span class="s">general</span><span class="se">\&#39;</span><span class="s">]/i[@name=</span><span class="se">\&#39;</span><span class="s">SYSTEM</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;generalName: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">generalName</span><span class="p">,)</span>



  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== electronic parameters =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="n">lst</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;parameters/separator[@name=</span><span class="se">\&#39;</span><span class="s">electronic</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;electronic parameters not found&#39;</span><span class="p">)</span>
  <span class="n">elecNode</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="c"># ialgo</span>
  <span class="c"># PyLada: use the 1 occurance of:</span>
  <span class="c">#   Electronic relaxation 2 (details)</span>
  <span class="c">#     IALGO  =     68    algorithm</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">ialgo</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">elecNode</span><span class="p">,</span> <span class="s">&#39;i[@name=</span><span class="se">\&#39;</span><span class="s">IALGO</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">ediff</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">elecNode</span><span class="p">,</span> <span class="s">&#39;i[@name=</span><span class="se">\&#39;</span><span class="s">EDIFF</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;ialgo: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">ialgo</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;ediff: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">ediff</span><span class="p">,)</span>

  <span class="c"># numBand = nbands</span>
  <span class="c"># Caution: in some cases NBANDS != eigenMrr[&#39;eigene&#39;].shape[2]</span>
  <span class="c"># So we use the eigene dimension instead.</span>
  <span class="c"># See further below.</span>
  <span class="n">prmNumBand</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">elecNode</span><span class="p">,</span> <span class="s">&#39;i[@name=</span><span class="se">\&#39;</span><span class="s">NBANDS</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;prmNumBand: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prmNumBand</span><span class="p">,)</span>

  <span class="c"># numElectron = nelect</span>
  <span class="c"># PyLada: vasp/extract/base.py: nelect()</span>
  <span class="c"># OUTCAR: use the 1 occurance of:</span>
  <span class="c">#     NELECT =      48.0000    total number of electrons</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">numElectron</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">elecNode</span><span class="p">,</span> <span class="s">&#39;i[@name=</span><span class="se">\&#39;</span><span class="s">NELECT</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;numElectron: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">numElectron</span><span class="p">,)</span>

  <span class="c"># icharg</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">icharg</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span>
    <span class="n">elecNode</span><span class="p">,</span>
    <span class="s">&#39;separator[@name=</span><span class="se">\&#39;</span><span class="s">electronic startup</span><span class="se">\&#39;</span><span class="s">]/i[@name=</span><span class="se">\&#39;</span><span class="s">ICHARG</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span>
    <span class="nb">int</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;icharg: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">icharg</span><span class="p">,)</span>

  <span class="c"># numSpin == ispin</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span>
    <span class="n">elecNode</span><span class="p">,</span> <span class="s">&#39;separator[@name=</span><span class="se">\&#39;</span><span class="s">electronic spin</span><span class="se">\&#39;</span><span class="s">]/i[@name=</span><span class="se">\&#39;</span><span class="s">ISPIN</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;numSpin: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span><span class="p">,)</span>



  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== ionic parameters =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># Some parameters like IBRION are also found in INCAR, sometimes.</span>
  <span class="c"># But apparently they are always in the ionic parameters section.</span>
  <span class="n">lst</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;parameters/separator[@name=</span><span class="se">\&#39;</span><span class="s">ionic</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;ionic parameters not found&#39;</span><span class="p">)</span>
  <span class="n">ionNode</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">ibrion</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">ionNode</span><span class="p">,</span> <span class="s">&#39;i[@name=</span><span class="se">\&#39;</span><span class="s">IBRION</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">isif</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">ionNode</span><span class="p">,</span> <span class="s">&#39;i[@name=</span><span class="se">\&#39;</span><span class="s">ISIF</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">posScaleFactor</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">ionNode</span><span class="p">,</span> <span class="s">&#39;i[@name=</span><span class="se">\&#39;</span><span class="s">SCALEE</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;ibrion: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">ibrion</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;isif: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">isif</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;posScaleFactor: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">posScaleFactor</span><span class="p">,)</span>


  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== symmetry parameters =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># Some parameters like ISYM are also found in INCAR, sometimes.</span>
  <span class="c"># But apparently they are always in the symmetry parameters section.</span>
  <span class="n">lst</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;parameters/separator[@name=</span><span class="se">\&#39;</span><span class="s">symmetry</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;symmetry parameters not found&#39;</span><span class="p">)</span>
  <span class="n">symNode</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">isym</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">symNode</span><span class="p">,</span> <span class="s">&#39;i[@name=</span><span class="se">\&#39;</span><span class="s">ISYM</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;isym: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">isym</span><span class="p">,)</span>


  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== writing parameters =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># Some parameters like LOPTICS are also found in INCAR, sometimes.</span>
  <span class="c"># But apparently they are always in the writing parameters section.</span>
  <span class="n">lst</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;parameters/separator[@name=</span><span class="se">\&#39;</span><span class="s">writing</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;writing parameters not found&#39;</span><span class="p">)</span>
  <span class="n">writeNode</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">loptics</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">writeNode</span><span class="p">,</span> <span class="s">&#39;i[@name=</span><span class="se">\&#39;</span><span class="s">LOPTICS</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">lwave</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">writeNode</span><span class="p">,</span> <span class="s">&#39;i[@name=</span><span class="se">\&#39;</span><span class="s">LWAVE</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;loptics: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">loptics</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;lwave: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">lwave</span><span class="p">,)</span>



  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== atom info =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># atomTypeMrr = map containing array.  Example (some whitespace omitted):</span>
  <span class="c">#   _dimLens: [2]</span>
  <span class="c">#   _dimNames: [&#39;type&#39;]</span>
  <span class="c">#   _fieldNames: [&#39;atomspertype&#39; &#39;element&#39; &#39;mass&#39; &#39;valence&#39; &#39;pseudopotential&#39;]</span>
  <span class="c">#   _fieldTypes: [&#39;i&#39; &#39;s&#39; &#39;f&#39; &#39;f&#39; &#39;s&#39;]</span>
  <span class="c">#   atomspertype: [1 4]</span>
  <span class="c">#   element: [&#39;C &#39; &#39;Fe&#39;]</span>
  <span class="c">#   mass: [ 12.011  55.847]</span>
  <span class="c">#   valence: [ 4.  8.]</span>
  <span class="c">#   pseudopotential: [&#39; PAW_PBE C_s 06Sep2000 &#39; &#39; PAW_PBE Fe 06Sep2000 &#39;]</span>

  <span class="n">atomTypeMrr</span> <span class="o">=</span> <span class="n">getArrayByPath</span><span class="p">(</span>
    <span class="n">bugLev</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;atominfo/array[@name=</span><span class="se">\&#39;</span><span class="s">atomtypes</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">typeNames</span>       <span class="o">=</span> <span class="n">atomTypeMrr</span><span class="p">[</span><span class="s">&#39;element&#39;</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">typeNums</span>        <span class="o">=</span> <span class="n">atomTypeMrr</span><span class="p">[</span><span class="s">&#39;atomspertype&#39;</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">typeMasses_amu</span>  <span class="o">=</span> <span class="n">atomTypeMrr</span><span class="p">[</span><span class="s">&#39;mass&#39;</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">typeValences</span>    <span class="o">=</span> <span class="n">atomTypeMrr</span><span class="p">[</span><span class="s">&#39;valence&#39;</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">typePseudos</span>     <span class="o">=</span> <span class="n">atomTypeMrr</span><span class="p">[</span><span class="s">&#39;pseudopotential&#39;</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">numAtom</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeNums</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">atomTypeMrr:&#39;</span>
    <span class="n">printMrr</span><span class="p">(</span> <span class="n">atomTypeMrr</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">atomTypes:&#39;</span>
    <span class="k">print</span> <span class="s">&#39;typeNames: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeNames</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;typeNums: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeNums</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;typeMasses_amu: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeMasses_amu</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;typeValences: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeValences</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;typePseudos: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typePseudos</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;numAtom: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numAtom</span><span class="p">,)</span>

  <span class="n">numType</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeNames</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeNums</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numType</span><span class="p">:</span> 
    <span class="bp">self</span><span class="o">.</span><span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;len( typeNums) mismatch&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeMasses_amu</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numType</span><span class="p">:</span> 
    <span class="bp">self</span><span class="o">.</span><span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;len( typeMasses_amu) mismatch&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeValences</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numType</span><span class="p">:</span> 
    <span class="bp">self</span><span class="o">.</span><span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;len( typeValences) mismatch&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typePseudos</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numType</span><span class="p">:</span> 
    <span class="bp">self</span><span class="o">.</span><span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;len( typePseudos) mismatch&#39;</span><span class="p">)</span>

  <span class="c">## Sort parallel arrays typeNames, typeNums, etc,</span>
  <span class="c">## by typeNames alphabetic order.</span>
  <span class="c">## Use an index sort with typeIxs.</span>
  <span class="c">## In rare cases like icsd_024360.cif/hs-ferro</span>
  <span class="c">## and icsd_060845_GW, the names are out of order.</span>

  <span class="c">## Sort to set typeIxs[newIx] == oldIx.</span>

  <span class="c">#typeIxs = range( numType)</span>
  <span class="c">#def sortFunc( ia, ib):</span>
  <span class="c">#  return cmp( resObj.typeNames[ia], resObj.typeNames[ib])</span>
  <span class="c">#typeIxs.sort( sortFunc)</span>
  <span class="c">#if bugLev &gt;= 5:</span>
  <span class="c">#  print &#39;typeIxs: %s&#39; % (typeIxs,)</span>

  <span class="c">#resObj.typeIxs        = typeIxs</span>
  <span class="c">#resObj.typeNames      = [resObj.typeNames[ix] for ix in typeIxs]</span>
  <span class="c">#resObj.typeNums       = [resObj.typeNums[ix] for ix in typeIxs]</span>
  <span class="c">#resObj.typeMasses_amu = [resObj.typeMasses_amu[ix] for ix in typeIxs]</span>
  <span class="c">#resObj.typeValences   = [resObj.typeValences[ix] for ix in typeIxs]</span>
  <span class="c">#resObj.typePseudos    = [resObj.typePseudos[ix] for ix in typeIxs]</span>

  <span class="c">#if bugLev &gt;= 5:</span>
  <span class="c">#  print &#39;\nsorted atomTypes:&#39;</span>
  <span class="c">#  print &#39;typeIxs: %s&#39; % ( resObj.typeIxs,)</span>
  <span class="c">#  print &#39;typeNames: %s&#39; % ( resObj.typeNames,)</span>
  <span class="c">#  print &#39;typeNums: %s&#39; % ( resObj.typeNums,)</span>
  <span class="c">#  print &#39;typeMasses_amu: %s&#39; % ( resObj.typeMasses_amu,)</span>
  <span class="c">#  print &#39;typeValences: %s&#39; % ( resObj.typeValences,)</span>
  <span class="c">#  print &#39;typePseudos: %s&#39; % ( resObj.typePseudos,)</span>








  <span class="c">## Old way to get atomNames, atomMasses, atomValences, atomPseudos.</span>
  <span class="c">## Retained in case some day we need it.</span>
  <span class="c">## But the real values are set in &quot;New way&quot;, below.</span>
  <span class="c">## atomMrr = map containing array.  Example:</span>
  <span class="c">##   _dimLens: [5]</span>
  <span class="c">##   _dimNames: [&#39;ion&#39;]</span>
  <span class="c">##   _fieldNames: [&#39;element&#39; &#39;atomtype&#39;]</span>
  <span class="c">##   _fieldTypes: [&#39;s&#39; &#39;i&#39;]</span>
  <span class="c">##   element: [&#39;C &#39; &#39;Fe&#39; &#39;Fe&#39; &#39;Fe&#39; &#39;Fe&#39;]</span>
  <span class="c">##   atomtype: [1 2 2 2 2]</span>

  <span class="c">#atomMrr = getArrayByPath(</span>
  <span class="c">#  bugLev, root, &#39;atominfo/array[@name=\&#39;atoms\&#39;]&#39;)</span>
  <span class="c">#oatomNames = atomMrr[&#39;element&#39;]</span>

  <span class="c">## oatomTypes are indices into typeNames, typeNums, typeMasses,</span>
  <span class="c">## typeValences, typePseudos</span>
  <span class="c">#oatomTypes = [ix - 1 for ix in atomMrr[&#39;atomtype&#39;]]  # change to origin 0</span>
  <span class="c">#natom = len( oatomTypes)</span>

  <span class="c">#if bugLev &gt;= 5:</span>
  <span class="c">#  print &#39;\natomMrr:&#39;</span>
  <span class="c">#  printMrr( atomMrr)</span>
  <span class="c">#  print &#39;\nunsorted atoms:&#39;</span>
  <span class="c">#  print &#39;oatomNames: %s&#39; % ( oatomNames,)</span>
  <span class="c">#  print &#39;oatomTypes: %s&#39; % ( oatomTypes,)</span>

  <span class="c">## The permutation array typeIxs maps typeIxs[newIx] = oldIx.</span>
  <span class="c">## Invert it to get typeIxInvs[oldIx] = newIx.</span>
  <span class="c">#typeIxInvs = numType * [0]</span>
  <span class="c">#for ii in range( numType):</span>
  <span class="c">#  typeIxInvs[ typeIxs[ii]] = ii</span>
  <span class="c">#if bugLev &gt;= 5:</span>
  <span class="c">#  print &#39;typeIxInvs: %s&#39; % (typeIxInvs,)</span>

  <span class="c">## Sort oatomNames, oatomTypes by typeIxInvs[atomtype] so they</span>
  <span class="c">## are in the same order as typenames, typenums, etc, above.</span>
  <span class="c">## Currently oatomTypes[i] = old index num into type*.</span>
  <span class="c">## We want to sort by new index num into type*.</span>

  <span class="c">## Sort to set oatomIxs[newIx] == oldIx.</span>

  <span class="c">#oatomIxs = range( natom)</span>
  <span class="c">#def sortFunc( ia, ib):</span>
  <span class="c">#  return cmp( typeIxInvs[ oatomTypes[ ia]], typeIxInvs[ oatomTypes[ ib]])</span>
  <span class="c">#oatomIxs.sort( sortFunc)</span>
  <span class="c">#oatomNames = [oatomNames[ix] for ix in oatomIxs]</span>
  <span class="c">#oatomTypes = [typeIxInvs[ oatomTypes[ix]] for ix in oatomIxs]</span>

  <span class="c">#if bugLev &gt;= 5:</span>
  <span class="c">#  print &#39;\noatomIxs: %s&#39; % (oatomIxs,)</span>
  <span class="c">#  print &#39;\nsorted atoms:&#39;</span>
  <span class="c">#  print &#39;oatomNames: %s&#39; % ( oatomNames,)</span>
  <span class="c">#  print &#39;oatomTypes: %s&#39; % ( oatomTypes,)</span>
  <span class="c">#    # indices into typeNames, typeNums</span>

  <span class="c">#oatomMasses_amu = natom * [None]</span>
  <span class="c">#oatomValences = natom * [None]</span>
  <span class="c">#oatomPseudos = natom * [None]</span>
  <span class="c">#for ii in range( natom):</span>
  <span class="c">#  ix = oatomTypes[ii]</span>
  <span class="c">#  if oatomNames[ii] != resObj.typeNames[ix]:</span>
  <span class="c">#    throwerr(&#39;name mismatch&#39;)</span>
  <span class="c">#  oatomMasses_amu[ii] = resObj.typeMasses_amu[ix]</span>
  <span class="c">#  oatomValences[ii] = resObj.typeValences[ix]</span>
  <span class="c">#  oatomPseudos[ii] = resObj.typePseudos[ix]</span>
  <span class="c">#if bugLev &gt;= 5:</span>
  <span class="c">#  print &#39;oatomNames: %s&#39; % ( oatomNames,)</span>
  <span class="c">#  print &#39;oatomTypes: %s&#39; % ( oatomTypes,)</span>
  <span class="c">#  print &#39;oatomMasses_amu: %s&#39; % ( oatomMasses_amu,)</span>
  <span class="c">#  print &#39;oatomValences: %s&#39; % ( oatomValences,)</span>
  <span class="c">#  print &#39;oatomPseudos: %s&#39; % ( oatomPseudos,)</span>

  <span class="c">## Make sure typenames are in alphabetic order</span>
  <span class="c">#for ii in range(len(resObj.typeNames) - 1):</span>
  <span class="c">#  if resObj.typeNames[ii] &gt; resObj.typeNames[ii+1]:</span>
  <span class="c">#    throwerr(&#39;typeNames not in order&#39;)</span>

  <span class="c">## Make sure atomnames are in alphabetic order</span>
  <span class="c">#for ii in range(len(resObj.atomNames) - 1):</span>
  <span class="c">#  if resObj.atomNames[ii] &gt; resObj.atomNames[ii+1]:</span>
  <span class="c">#    throwerr(&#39;atomNames not in order&#39;)</span>




  <span class="c"># New way to get atomNames, atomMasses, atomValences, atomPseudos</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">atomNames</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">atomMasses_amu</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">atomValences</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">atomPseudos</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">numType</span><span class="p">):</span>
    <span class="n">nn</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeNums</span><span class="p">[</span> <span class="n">ii</span><span class="p">]</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">atomNames</span> <span class="o">+=</span> <span class="n">nn</span> <span class="o">*</span> <span class="p">[</span><span class="n">resObj</span><span class="o">.</span><span class="n">typeNames</span><span class="p">[</span><span class="n">ii</span><span class="p">]]</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">atomMasses_amu</span> <span class="o">+=</span> <span class="n">nn</span> <span class="o">*</span> <span class="p">[</span><span class="n">resObj</span><span class="o">.</span><span class="n">typeMasses_amu</span><span class="p">[</span><span class="n">ii</span><span class="p">]]</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">atomValences</span> <span class="o">+=</span> <span class="n">nn</span> <span class="o">*</span> <span class="p">[</span><span class="n">resObj</span><span class="o">.</span><span class="n">typeValences</span><span class="p">[</span><span class="n">ii</span><span class="p">]]</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">atomPseudos</span> <span class="o">+=</span> <span class="n">nn</span> <span class="o">*</span> <span class="p">[</span><span class="n">resObj</span><span class="o">.</span><span class="n">typePseudos</span><span class="p">[</span><span class="n">ii</span><span class="p">]]</span>
  <span class="n">numAtom</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">atomNames</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== initial structure =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># Initial structure</span>
  <span class="c"># PyLada: vasp/extract/base.py: initial_structure()</span>
  <span class="c"># OUTCAR: uses the appended INITIAL STRUCTURE section.</span>
  <span class="n">lst</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span>
    <span class="s">&#39;structure[@name=</span><span class="se">\&#39;</span><span class="s">initialpos</span><span class="se">\&#39;</span><span class="s">]/crystal/varray[@name=</span><span class="se">\&#39;</span><span class="s">basis</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;len(lst) a:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>

  <span class="c"># initial_structure</span>
  <span class="c"># POSCAR specifies each basis vector as one row.</span>
  <span class="c"># So does vasprun.xml.</span>
  <span class="c"># But PyLada&#39;s structure.cell is the transpose: each basis vec is a column.</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">initialBasisMat</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span>
    <span class="s">&#39;structure[@name=</span><span class="se">\&#39;</span><span class="s">initialpos</span><span class="se">\&#39;</span><span class="s">]/crystal/varray[@name=</span><span class="se">\&#39;</span><span class="s">basis</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">initialRecipBasisMat</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span>
    <span class="s">&#39;structure[@name=</span><span class="se">\&#39;</span><span class="s">initialpos</span><span class="se">\&#39;</span><span class="s">]/crystal/varray[@name=</span><span class="se">\&#39;</span><span class="s">rec_basis</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

  <span class="c"># Get initialFracPosMat</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">initialFracPosMat</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span>
    <span class="s">&#39;structure[@name=</span><span class="se">\&#39;</span><span class="s">initialpos</span><span class="se">\&#39;</span><span class="s">]/varray[@name=</span><span class="se">\&#39;</span><span class="s">positions</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="c"># xxx Check: nrow should be numAtom</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">initialCartPosMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">initialFracPosMat</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">initialBasisMat</span><span class="p">)</span>
  <span class="c"># xxx mult by scale factor?</span>

  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;initialBasisMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">initialBasisMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;initialRecipBasisMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">initialRecipBasisMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;initialFracPosMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">initialFracPosMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;initialCartPosMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">initialCartPosMat</span><span class="p">),)</span>



  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== final structure =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># structure == final pos</span>
  <span class="c"># POSCAR and OUTCAR specify each basis vector as one row.</span>
  <span class="c"># So does vasprun.xml.</span>
  <span class="c"># But PyLada&#39;s structure.cell is the transpose: each basis vec is a column.</span>
  <span class="c">#</span>
  <span class="c"># In vasprun.xml and OUTCAR, the basis vectors are rows.</span>
  <span class="n">finalPath</span> <span class="o">=</span> <span class="s">&#39;structure[@name=</span><span class="se">\&#39;</span><span class="s">finalpos</span><span class="se">\&#39;</span><span class="s">]/crystal/varray[@name=</span><span class="se">\&#39;</span><span class="s">basis</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span>
  <span class="n">nodes</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span> <span class="n">finalPath</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">finalBasisMat</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">finalRecipBasisMat</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">finalFracPosMat</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">finalCartPosMat</span> <span class="o">=</span> <span class="bp">None</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">finalBasisMat</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
      <span class="n">root</span><span class="p">,</span>
      <span class="n">finalPath</span><span class="p">,</span>
      <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">finalRecipBasisMat</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
      <span class="n">root</span><span class="p">,</span>
      <span class="s">&#39;structure[@name=</span><span class="se">\&#39;</span><span class="s">finalpos</span><span class="se">\&#39;</span><span class="s">]/crystal/varray[@name=</span><span class="se">\&#39;</span><span class="s">rec_basis</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">,</span>
      <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

    <span class="c"># Get finalFracPosMat</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">finalFracPosMat</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
      <span class="n">root</span><span class="p">,</span>
      <span class="s">&#39;structure[@name=</span><span class="se">\&#39;</span><span class="s">finalpos</span><span class="se">\&#39;</span><span class="s">]/varray[@name=</span><span class="se">\&#39;</span><span class="s">positions</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">,</span>
      <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>    <span class="c"># xxx nrow should be numAtom</span>
    <span class="c"># xxx Check: nrow should be numAtom</span>

    <span class="n">resObj</span><span class="o">.</span><span class="n">finalCartPosMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
      <span class="n">resObj</span><span class="o">.</span><span class="n">finalFracPosMat</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">finalBasisMat</span><span class="p">)</span>
    <span class="c"># xxx mult by scale factor?</span>

  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;finalBasisMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalBasisMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;finalRecipBasisMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalRecipBasisMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;finalFracPosMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalFracPosMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;finalCartPosMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalCartPosMat</span><span class="p">),)</span>


  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== magmom =====</span><span class="se">\n</span><span class="s">&#39;</span>
  <span class="c"># Apparently the magnetization values are only in OUTCAR</span>
  <span class="c"># See ScanOutcar.py.</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">magmoms</span> <span class="o">=</span> <span class="bp">None</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;magmoms: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">magmoms</span><span class="p">,)</span>



  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== kpoints =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># kpoint coordinates.</span>
  <span class="c"># In gw the kpoints get updated, so we use the last.</span>
  <span class="c"># Not in PyLada?</span>
  <span class="n">lst</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span> <span class="s">&#39;kpoints/varray[@name=</span><span class="se">\&#39;</span><span class="s">kpointlist</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;kpoints varray not found&#39;</span><span class="p">)</span>
  <span class="n">kpointsNode</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">kpointFracMat</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span> <span class="n">kpointsNode</span><span class="p">,</span> <span class="s">&#39;v&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">numKpoint</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">kpointFracMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">kpointCartMat</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">posScaleFactor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">kpointFracMat</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">initialRecipBasisMat</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;numKpoint: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">numKpoint</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;kpointFracMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">kpointFracMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;kpointCartMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">kpointCartMat</span><span class="p">),)</span>

  <span class="c"># This is what PyLada calls multiplicity.</span>
  <span class="c"># The only diff is the scaling.</span>
  <span class="c">#   sum( Pylada multiplicity) = numKpoint</span>
  <span class="c">#   sum( our kpointWeights) = 1.0</span>
  <span class="n">lst</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span> <span class="s">&#39;kpoints/varray[@name=</span><span class="se">\&#39;</span><span class="s">weights</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;weights varray not found&#39;</span><span class="p">)</span>
  <span class="n">weightsNode</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">kpointWeights</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span> <span class="n">weightsNode</span><span class="p">,</span> <span class="s">&#39;v&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">kpointWeights</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">kpointWeights</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>   <span class="c"># Only 1 col in 2d array</span>
  <span class="k">if</span> <span class="n">resObj</span><span class="o">.</span><span class="n">kpointWeights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numKpoint</span><span class="p">:</span>
    <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;numKpoint mismatch&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;kpointWeights:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">kpointWeights</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;kpointWeights sum: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">kpointWeights</span><span class="p">),)</span>



  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== final volume =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="n">volPath</span> <span class="o">=</span> <span class="s">&#39;structure[@name=</span><span class="se">\&#39;</span><span class="s">finalpos</span><span class="se">\&#39;</span><span class="s">]/crystal/i[@name=</span><span class="se">\&#39;</span><span class="s">volume</span><span class="se">\&#39;</span><span class="s">]&#39;</span>
  <span class="n">nodes</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span> <span class="n">volPath</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">finalVolume_ang3</span> <span class="o">=</span> <span class="bp">None</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">finalVolume_ang3</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">volPath</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;finalVolume_ang3: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalVolume_ang3</span><span class="p">,)</span>



  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== last calc forces =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="n">forcePath</span> <span class="o">=</span> <span class="s">&#39;calculation[last()]/varray[@name=</span><span class="se">\&#39;</span><span class="s">forces</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span>
  <span class="n">nodes</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span> <span class="n">forcePath</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">finalForceMat_ev_ang</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">finalStressMat_kbar</span> <span class="o">=</span> <span class="bp">None</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c"># Get forceMat</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">finalForceMat_ev_ang</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
      <span class="n">root</span><span class="p">,</span> <span class="n">forcePath</span><span class="p">,</span>
      <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="c"># Sometimes forceMat can have a few NaN elements,</span>
    <span class="c"># which postgresql calls invalid.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">finalForceMat_ev_ang</span><span class="o">.</span><span class="n">flat</span><span class="p">)):</span>
      <span class="n">resObj</span><span class="o">.</span><span class="n">finalForceMat_ev_ang</span> <span class="o">=</span> <span class="bp">None</span>
      <span class="n">resObj</span><span class="o">.</span><span class="n">finalStressMat_kbar</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c"># Get stressMat</span>
      <span class="n">resObj</span><span class="o">.</span><span class="n">finalStressMat_kbar</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
        <span class="n">root</span><span class="p">,</span> <span class="s">&#39;calculation[last()]/varray[@name=</span><span class="se">\&#39;</span><span class="s">stress</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">,</span>
        <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;finalForceMat_ev_ang:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalForceMat_ev_ang</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;finalStressMat_kbar:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalStressMat_kbar</span><span class="p">),)</span>



  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== eigenvalues and occupancies =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># PyLada: eigenvalues</span>
  <span class="n">eigenPath</span> <span class="o">=</span> <span class="s">&#39;calculation[last()]/eigenvalues/array&#39;</span>
  <span class="n">nodes</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span> <span class="n">eigenPath</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">numBand</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">eigenMat</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">occupMat</span> <span class="o">=</span> <span class="bp">None</span>

  <span class="k">else</span><span class="p">:</span>
    <span class="n">eigenMrr</span> <span class="o">=</span> <span class="n">getArrayByPath</span><span class="p">(</span> <span class="n">bugLev</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">eigenPath</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">eigenMrr beg =====:&#39;</span>
      <span class="n">printMrr</span><span class="p">(</span> <span class="n">eigenMrr</span><span class="p">)</span>
      <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">eigenMrr end =====:&#39;</span>
      <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">eigenMrr: eigene[isp=</span><span class="si">%d</span><span class="s">][0]</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> \
          <span class="o">%</span> <span class="p">(</span><span class="n">isp</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">eigenMrr</span><span class="p">[</span><span class="s">&#39;eigene&#39;</span><span class="p">][</span><span class="n">isp</span><span class="p">][</span><span class="mi">0</span><span class="p">]),)</span>
        <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">eigenMrr: occ[isp=</span><span class="si">%d</span><span class="s">][0]</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> \
          <span class="o">%</span> <span class="p">(</span><span class="n">isp</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">eigenMrr</span><span class="p">[</span><span class="s">&#39;occ&#39;</span><span class="p">][</span><span class="n">isp</span><span class="p">][</span><span class="mi">0</span><span class="p">]),)</span>

    <span class="n">shp</span> <span class="o">=</span> <span class="n">eigenMrr</span><span class="p">[</span><span class="s">&#39;_dimLens&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;eigenMrr shape: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">shp</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">shp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;numSpin mismatch&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numKpoint</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;numKpoint mismatch&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">prmNumBand</span><span class="p">:</span>     <span class="c"># see caution at prmNumBand, above</span>
      <span class="k">print</span><span class="p">(</span><span class="s">&#39;numBand mismatch: prm: </span><span class="si">%d</span><span class="s">  shape: </span><span class="si">%d</span><span class="s">  inFile: </span><span class="si">%s</span><span class="s">&#39;</span> \
        <span class="o">%</span> <span class="p">(</span><span class="n">prmNumBand</span><span class="p">,</span> <span class="n">shp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">inFile</span><span class="p">,))</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">numBand</span> <span class="o">=</span> <span class="n">shp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">resObj</span><span class="o">.</span><span class="n">eigenMat</span> <span class="o">=</span> <span class="n">eigenMrr</span><span class="p">[</span><span class="s">&#39;eigene&#39;</span><span class="p">]</span>
    <span class="c"># Caution: for non-magnetic (numSpin==1),</span>
    <span class="c">#   OUTCAR has occupMat values = 2, while vasprun.xml has values = 1.</span>
    <span class="c"># For magnetic (numSpin==2), both OUTCAR and vasprun.xml have 1.</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">occupMat</span> <span class="o">=</span> <span class="n">eigenMrr</span><span class="p">[</span><span class="s">&#39;occ&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">resObj</span><span class="o">.</span><span class="n">occupMat</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;resObj.eigenMat.shape: &#39;</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">eigenMat</span><span class="o">.</span><span class="n">shape</span>
      <span class="k">print</span> <span class="s">&#39;resObj.occupMat.shape: &#39;</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">occupMat</span><span class="o">.</span><span class="n">shape</span>
    
    <span class="c"># Compare projected and standard eigenvalues</span>
    <span class="n">getProjected</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">getProjected</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span><span class="p">):</span>
        <span class="n">projEigenMrr</span> <span class="o">=</span> <span class="n">getArrayByPath</span><span class="p">(</span>
          <span class="n">bugLev</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;calculation[last()]/projected/eigenvalues/array&#39;</span><span class="p">)</span>
        
        <span class="c"># eigs and projected eigs are identical</span>
        <span class="n">eigs</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">eigenMrr</span><span class="p">[</span><span class="s">&#39;eigene&#39;</span><span class="p">][</span><span class="n">isp</span><span class="p">]</span>
        <span class="n">peigs</span> <span class="o">=</span> <span class="n">projEigenMrr</span><span class="p">[</span><span class="s">&#39;eigene&#39;</span><span class="p">][</span><span class="n">isp</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
          <span class="k">print</span> <span class="s">&#39;Compare iegs, peigs for isp: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">isp</span><span class="p">,)</span>
          <span class="k">print</span> <span class="s">&#39;  eigs.shape:  &#39;</span><span class="p">,</span> <span class="n">eigs</span><span class="o">.</span><span class="n">shape</span>
          <span class="k">print</span> <span class="s">&#39;  peigs.shape: &#39;</span><span class="p">,</span> <span class="n">peigs</span><span class="o">.</span><span class="n">shape</span>
          <span class="k">print</span> <span class="s">&#39;  eigs[0,:]: &#39;</span><span class="p">,</span> <span class="n">eigs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
          <span class="k">print</span> <span class="s">&#39;  peigs[0,:]: &#39;</span><span class="p">,</span> <span class="n">peigs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
          <span class="k">print</span> <span class="s">&#39;  Diff projeigs - eigs: max maxabs: </span><span class="si">%g</span><span class="s">&#39;</span> \
            <span class="o">%</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span> <span class="nb">map</span><span class="p">(</span> <span class="nb">max</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">peigs</span> <span class="o">-</span> <span class="n">eigs</span><span class="p">))),)</span>

        <span class="c"># occs and projected occs are identical</span>
        <span class="n">occs</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">eigenMrr</span><span class="p">[</span><span class="s">&#39;occ&#39;</span><span class="p">][</span><span class="n">isp</span><span class="p">]</span>
        <span class="n">poccs</span> <span class="o">=</span> <span class="n">projEigenMrr</span><span class="p">[</span><span class="s">&#39;occ&#39;</span><span class="p">][</span><span class="n">isp</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
          <span class="k">print</span> <span class="s">&#39;Compare occs, poccs for isp: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">isp</span><span class="p">,)</span>
          <span class="k">print</span> <span class="s">&#39;  occs.shape:  &#39;</span><span class="p">,</span> <span class="n">occs</span><span class="o">.</span><span class="n">shape</span>
          <span class="k">print</span> <span class="s">&#39;  poccs.shape: &#39;</span><span class="p">,</span> <span class="n">poccs</span><span class="o">.</span><span class="n">shape</span>
          <span class="k">print</span> <span class="s">&#39;  occs[0,:]: &#39;</span><span class="p">,</span> <span class="n">occs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
          <span class="k">print</span> <span class="s">&#39;  poccs[0,:]: &#39;</span><span class="p">,</span> <span class="n">poccs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
          <span class="k">print</span> <span class="s">&#39;  Diff projoccs - occs: max maxabs: </span><span class="si">%g</span><span class="s">&#39;</span> \
            <span class="o">%</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span> <span class="nb">map</span><span class="p">(</span> <span class="nb">max</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">poccs</span> <span class="o">-</span> <span class="n">occs</span><span class="p">))),)</span>



  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== dielectric function =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="n">imagPath</span> <span class="o">=</span> <span class="s">&#39;calculation[last()]/dielectricfunction/imag/array&#39;</span>
  <span class="n">nodes</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span> <span class="n">imagPath</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">dielectricImag</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">dielectricReal</span> <span class="o">=</span> <span class="bp">None</span>

  <span class="k">else</span><span class="p">:</span>
    <span class="n">dielImagMrr</span> <span class="o">=</span> <span class="n">getArrayByPath</span><span class="p">(</span> <span class="n">bugLev</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">imagPath</span><span class="p">)</span>
    <span class="n">dielRealMrr</span> <span class="o">=</span> <span class="n">getArrayByPath</span><span class="p">(</span>
      <span class="n">bugLev</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;calculation[last()]/dielectricfunction/real/array&#39;</span><span class="p">)</span>
    <span class="n">ndielectric</span> <span class="o">=</span> <span class="n">dielImagMrr</span><span class="p">[</span><span class="s">&#39;energy&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dielectricImag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ndielectric</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>    <span class="c"># E,xx,yy,zz,xy,yz,zx</span>
    <span class="n">dielectricReal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ndielectric</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>    <span class="c"># E,xx,yy,zz,xy,yz,zx</span>

    <span class="n">dietags</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;energy&#39;</span><span class="p">,</span> <span class="s">&#39;xx&#39;</span><span class="p">,</span> <span class="s">&#39;yy&#39;</span><span class="p">,</span> <span class="s">&#39;zz&#39;</span><span class="p">,</span> <span class="s">&#39;xy&#39;</span><span class="p">,</span> <span class="s">&#39;yz&#39;</span><span class="p">,</span> <span class="s">&#39;zx&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">dietags</span><span class="p">)):</span>
      <span class="n">tag</span> <span class="o">=</span> <span class="n">dietags</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
      <span class="n">immat</span> <span class="o">=</span> <span class="n">dielImagMrr</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
      <span class="n">remat</span> <span class="o">=</span> <span class="n">dielRealMrr</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">ndielectric</span><span class="p">):</span>
        <span class="n">dielectricImag</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">immat</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">dielectricReal</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">remat</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

    <span class="n">resObj</span><span class="o">.</span><span class="n">dielectricImag</span> <span class="o">=</span> <span class="n">dielectricImag</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">dielectricReal</span> <span class="o">=</span> <span class="n">dielectricReal</span>

    <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">dielImagMrr:&#39;</span>
      <span class="n">printMrr</span><span class="p">(</span> <span class="n">dielImagMrr</span><span class="p">)</span>
      <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">dielRealMrr:&#39;</span>
      <span class="n">printMrr</span><span class="p">(</span> <span class="n">dielRealMrr</span><span class="p">)</span>

      <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">dielectricImag:&#39;</span>
      <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">ndielectric</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&#39;  [</span><span class="si">%d</span><span class="s">]: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">dielectricImag</span><span class="p">[</span><span class="n">ii</span><span class="p">,:],)</span>
      <span class="k">print</span> <span class="s">&#39;&#39;</span>
      <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">dielectricReal:&#39;</span>
      <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">ndielectric</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&#39;  [</span><span class="si">%d</span><span class="s">]: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">dielectricReal</span><span class="p">[</span><span class="n">ii</span><span class="p">,:],)</span>
      <span class="k">print</span> <span class="s">&#39;&#39;</span>
      
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== misc junk =====</span><span class="se">\n</span><span class="s">&#39;</span>


  <span class="c"># functional: comes from appended FUNCTIONAL.</span>

  <span class="c"># success: look for final section</span>
  <span class="c">#   General timing and accounting informations for this job:</span>

  <span class="c"># xxx skip: Hubbard / NLEP</span>

  

  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== energy, efermi0 =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="n">energyPath</span> <span class="o">=</span> <span class="s">&#39;calculation/energy/i[@name=</span><span class="se">\&#39;</span><span class="s">e_wo_entrp</span><span class="se">\&#39;</span><span class="s">]&#39;</span>
  <span class="n">nodes</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span> <span class="n">energyPath</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">energyNoEntrps</span> <span class="o">=</span> <span class="bp">None</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">energyNoEntrps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
      <span class="n">txt</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
      <span class="n">resObj</span><span class="o">.</span><span class="n">energyNoEntrps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="nb">float</span><span class="p">(</span> <span class="n">txt</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;energyNoEntrps: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">energyNoEntrps</span><span class="p">,)</span>

  <span class="c"># efermi0</span>
  <span class="c"># PyLada uses an algorithm to compare the sum of occupancies</span>
  <span class="c"># to the valence.</span>
  <span class="c"># We get it from the xml file here.</span>
  <span class="c">#   PyLada: 5.8574</span>
  <span class="c">#   XML:    5.93253</span>

  <span class="n">efermiPath</span> <span class="o">=</span> <span class="s">&#39;calculation[last()]/dos/i[@name=</span><span class="se">\&#39;</span><span class="s">efermi</span><span class="se">\&#39;</span><span class="s">]&#39;</span>
  <span class="n">nodes</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span> <span class="n">efermiPath</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">efermi0</span> <span class="o">=</span> <span class="bp">None</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">efermi0</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">efermiPath</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;efermi0: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">efermi0</span><span class="p">,)</span>

  <span class="k">return</span>


  <span class="c">########################### End of parseXml ###############################</span>


  <span class="c"># The following code was used for initial testing,</span>
  <span class="c"># and who knows, someday may be useful again.</span>

  <span class="c">#print &#39;\n&#39;</span>
  <span class="c">#print &#39;\ntesta:&#39;</span>
  <span class="c">#lst = root.findall(&#39;kpoints/generation/v[@name=\&#39;genvec2\&#39;]&#39;)</span>
  <span class="c">#amat = []</span>
  <span class="c">#for ele in lst:</span>
  <span class="c">#  text = ele.text</span>
  <span class="c">#  print &#39;  ele.text: %s&#39; % (text,)</span>
  <span class="c">#  toks = text.split()</span>
  <span class="c">#  vals = map( float, toks)</span>
  <span class="c">#  amat.append( vals)</span>
  <span class="c">#print &#39;amat: %s&#39; % (amat,)</span>

  <span class="c">#amat = np.array( amat, dtype=float)</span>
  <span class="c">#print &#39;amat:\n%s&#39; % (amat,)</span>

  <span class="c">#vec = getVec( root, &#39;kpoints/generation/v[@name=\&#39;genvec2\&#39;]&#39;, 0, 0, float)</span>
  <span class="c">#print &#39;vec:\n%s&#39; % (vec,)</span>

  <span class="c">#amat = getRawArray( root, &#39;kpoints/generation/v&#39;, 0, 0, float)</span>
  <span class="c">#print &#39;amat:\n%s&#39; % (amat,)</span>

  <span class="c">#calcNodes = root.findall(&#39;calculation&#39;)</span>
  <span class="c">#print &#39;\nlen(calcNodes): %d&#39; % (len(calcNodes,))</span>

  <span class="c">## pairs: (itot, en_wo_entrp) for the energy of each scstep</span>
  <span class="c">#scstep_withouts = []</span>
  <span class="c">## pairs: (itot, en_wo_entrp) for the last energy of each calculation step</span>
  <span class="c">#calcstep_withouts = []</span>

  <span class="c">#basisMats = []</span>
  <span class="c">#recipBasisMats = []</span>
  <span class="c">#posMats = []</span>
  <span class="c">#forceMats = []</span>
  <span class="c">#stressMats = []</span>

  <span class="c">#itot = 0     # index all scsteps, across calculations</span>

  <span class="c">#ncalc = len( calcNodes)</span>
  <span class="c">#for icalc in range( ncalc):</span>
  <span class="c">#  cnode = calcNodes[icalc]</span>
  <span class="c">#  forceMat = getRawArray( cnode, &#39;varray[@name=\&#39;forces\&#39;]/v&#39;, 0, 0, float)</span>
  <span class="c">#  print &#39;\nforceMat for calcNodes[%d]:\n%s&#39; % (icalc, forceMat,)</span>
  <span class="c">#  scNodes = cnode.findall(&#39;scstep&#39;)</span>
  <span class="c">#  print &#39;    len(scNodes): %d&#39; % (len(scNodes,))</span>
  <span class="c">#  for isc in range(len(scNodes)):</span>
  <span class="c">#    snode = scNodes[isc]</span>
  <span class="c">#    sc_e_fr = getScalar( snode, &#39;energy/i[@name=\&#39;e_fr_energy\&#39;]&#39;, float)</span>
  <span class="c">#    sc_e_wo = getScalar( snode, &#39;energy/i[@name=\&#39;e_wo_entrp\&#39;]&#39;, float)</span>
  <span class="c">#    sc_e_0  = getScalar( snode, &#39;energy/i[@name=\&#39;e_0_energy\&#39;]&#39;, float)</span>
  <span class="c">#    print &#39;    scNodes[%d]: sc_e_fr: %g  sc_e_wo: %g  sc_e_0: %g&#39; \</span>
  <span class="c">#      % (isc, sc_e_fr, sc_e_wo, sc_e_0,)</span>

  <span class="c">#    scstep_withouts.append( (itot, sc_e_wo,))</span>
  <span class="c">#    itot += 1</span>

  <span class="c">#  # Structure for this calculation step</span>
  <span class="c">#  strucNodes = cnode.findall(&#39;structure&#39;)</span>
  <span class="c">#  if len(strucNodes) != 1: throwerr(&#39;calc structure not found&#39;)</span>
  <span class="c">#  snode = strucNodes[0]</span>
  <span class="c">#  basisMat = getRawArray(</span>
  <span class="c">#    snode, &#39;crystal/varray[@name=\&#39;basis\&#39;]/v&#39;, 3, 3, float)</span>
  <span class="c">#  recipBasisMat = getRawArray(</span>
  <span class="c">#    snode, &#39;crystal/varray[@name=\&#39;rec_basis\&#39;]/v&#39;, 3, 3, float)</span>
  <span class="c">#  # xxx should be nrow = num atoms</span>
  <span class="c">#  posMat = getRawArray(</span>
  <span class="c">#    snode, &#39;varray[@name=\&#39;positions\&#39;]/v&#39;, 0, 3, float)</span>
  <span class="c">#  print &#39;  Calc final: basisMat:\n%s&#39; % (basisMat,)</span>
  <span class="c">#  print &#39;  Calc final: recipBasisMat:\n%s&#39; % (recipBasisMat,)</span>
  <span class="c">#  print &#39;  Calc final: posMat:\n%s&#39; % (posMat,)</span>
  <span class="c">#  basisMats.append( basisMat)</span>
  <span class="c">#  recipBasisMats.append( recipBasisMat)</span>
  <span class="c">#  posMats.append( posMat)</span>

  <span class="c">#  # Forces for this calculation step</span>
  <span class="c">#  forceNodes = cnode.findall(&#39;varray[@name=\&#39;forces\&#39;]&#39;)</span>
  <span class="c">#  if len(forceNodes) != 1: throwerr(&#39;calc forces not found&#39;)</span>
  <span class="c">#  forceMat = getRawArray( forceNodes[0], &#39;v&#39;, 0, 3, float)</span>
  <span class="c">#  print &#39;  Calc final: forceMat:\n%s&#39; % (forceMat,)</span>
  <span class="c">#  forceMats.append( forceMat)</span>

  <span class="c">#  # Stress for this calculation step</span>
  <span class="c">#  stressNodes = cnode.findall(&#39;varray[@name=\&#39;stress\&#39;]&#39;)</span>
  <span class="c">#  if len(stressNodes) != 1: throwerr(&#39;calc stresses not found&#39;)</span>
  <span class="c">#  stressMat = getRawArray( stressNodes[0], &#39;v&#39;, 3, 3, float)</span>
  <span class="c">#  print &#39;  Calc final: stressMat:\n%s&#39; % (stressMat,)</span>
  <span class="c">#  stressMats.append( stressMat)</span>

  <span class="c">#  # Final energy for this calculation step</span>
  <span class="c">#  enNodes = cnode.findall(&#39;energy&#39;)</span>
  <span class="c">#  if len(enNodes) != 1: throwerr(&#39;calc energy not found&#39;)</span>
  <span class="c">#  enode = enNodes[0]</span>
  <span class="c">#  c_e_fr = getScalar( enode, &#39;i[@name=\&#39;e_fr_energy\&#39;]&#39;, float)</span>
  <span class="c">#  c_e_wo = getScalar( enode, &#39;i[@name=\&#39;e_wo_entrp\&#39;]&#39;, float)</span>
  <span class="c">#  c_e_0  = getScalar( enode, &#39;i[@name=\&#39;e_0_energy\&#39;]&#39;, float)</span>
  <span class="c">#  print &#39;  Calc final: c_e_fr: %g  c_e_wo: %g  c_e_0: %g&#39; \</span>
  <span class="c">#    % (c_e_fr, c_e_wo, c_e_0,)</span>
  <span class="c">#  calcstep_withouts.append( (itot - 1, c_e_wo,))</span>

  <span class="c">#print &#39;&#39;</span>
  <span class="c">#print &#39;scstep_withouts: %s&#39; % (scstep_withouts,)</span>
  <span class="c">#print &#39;&#39;</span>
  <span class="c">#print &#39;calcstep_withouts: %s&#39; % (calcstep_withouts,)</span>

  <span class="c">#scmat = np.array( scstep_withouts, dtype=float)</span>
  <span class="c">#print &#39;&#39;</span>
  <span class="c">#print &#39;scmat:\n%s&#39; % (scmat,)</span>

  <span class="c">#calcmat = np.array( calcstep_withouts, dtype=float)</span>
  <span class="c">#print &#39;&#39;</span>
  <span class="c">#print &#39;calcmat:\n%s&#39; % (calcmat,)</span>


  <span class="c">#print &#39;&#39;</span>
  <span class="c">#print &#39;Investigate DOS&#39;</span>
  <span class="c">#icals = len(calcNodes) - 1</span>
  <span class="c">#cnode = calcNodes[icalc]</span>
  <span class="c">#setNodes = cnode.findall(&#39;dos/total/array/set/set[@comment=\&#39;spin 1\&#39;]&#39;)</span>
  <span class="c">#print &#39;    len(total setNodes): %d&#39; % (len(setNodes),)</span>
  <span class="c">#print &#39;    setNodes[0]: %s&#39; % (setNodes[0],)</span>
  <span class="c">#if len(setNodes) != 1: throwerr(&#39;dos/total not found&#39;)</span>
  <span class="c">#dosTotalMat = getRawArray( setNodes[0], &#39;r&#39;, 0, 0, float)</span>
  <span class="c">#print &#39;&#39;</span>
  <span class="c">#print &#39;type(dosTotalMat): &#39;, type(dosTotalMat)</span>
  <span class="c">#print &#39;dosTotalMat.shape: &#39;, dosTotalMat.shape</span>
  <span class="c">#print &#39;&#39;</span>
  <span class="c">#print &#39;dosTotalMat:\n%s&#39; % (dosTotalMat,)</span>

  <span class="c">#dosPartialMats = []</span>
  <span class="c">#partialSetNodes = cnode.findall(&#39;dos/partial/array/set&#39;)</span>
  <span class="c">#print &#39;    len(partialSetNodes): %d&#39; % (len(partialSetNodes),)</span>
  <span class="c">#if len(partialSetNodes) != 1: throwerr(&#39;dos/partial not found&#39;)</span>
  <span class="c">#partialSet = partialSetNodes[0]</span>

  <span class="c">#ionNodes = partialSet.findall(&#39;set&#39;)</span>
  <span class="c">#print &#39;    len(ionNodes): %d&#39; % (len(ionNodes),)</span>
  <span class="c">## xxx should be nrow = num atoms</span>
  <span class="c">#for ii in range(len(ionNodes)):</span>
  <span class="c">#  dosPartialMat = getRawArray(</span>
  <span class="c">#    ionNodes[ii], &#39;set[@comment=\&#39;spin 1\&#39;]/r&#39;, 0, 0, float)</span>
  <span class="c">#  print &#39;&#39;</span>
  <span class="c">#  print &#39;dosPartialMat %d:&#39; % (ii,)</span>
  <span class="c">#  print &#39;type(dosPartialMat): &#39;, type(dosPartialMat)</span>
  <span class="c">#  print &#39;dosPartialMat.shape: &#39;, dosPartialMat.shape</span>
  <span class="c">#  print &#39;&#39;</span>
  <span class="c">#  print &#39;dosPartialMat:\n%s&#39; % (dosPartialMat,)</span>
  <span class="c">#  dosPartialMats.append( dosPartialMat)</span>

  <span class="c">#print &#39;len(dosPartialMats): %d&#39; % (len(dosPartialMats),)</span>




  <span class="c">#print &#39;\nbasisMats:  len: %d&#39; % (len(basisMats),)</span>
  <span class="c">#for mat in basisMats: print &#39;%s&#39; % (mat,)</span>

  <span class="c">#print &#39;\nrecipBasisMats:  len: %d&#39; % (len(recipBasisMats),)</span>
  <span class="c">#for mat in recipBasisMats: print &#39;%s&#39; % (mat,)</span>

  <span class="c">#print &#39;\nposMats:  len: %d&#39; % (len(posMats),)</span>
  <span class="c">#for mat in posMats: print &#39;%s&#39; % (mat,)</span>

  <span class="c">#print &#39;\nforceMats:  len: %d&#39; % (len(forceMats),)</span>
  <span class="c">#for mat in forceMats: print &#39;%s&#39; % (mat,)</span>

  <span class="c">#print &#39;\nstressMats:  len: %d&#39; % (len(stressMats),)</span>
  <span class="c">#for mat in stressMats: print &#39;%s&#39; % (mat,)</span>

  <span class="c">#basisDeltas = calcMatDeltas( basisMats)</span>
  <span class="c">#recipBasisDeltas = calcMatDeltas( recipBasisMats)</span>
  <span class="c">#posDeltas = calcMatDeltas( posMats)</span>
  <span class="c">#forceDeltas = calcMatDeltas( forceMats)</span>
  <span class="c">#stressDeltas = calcMatDeltas( stressMats)</span>

  <span class="c">#print &#39;basisDeltas: %s&#39; % ( basisDeltas,)</span>
  <span class="c">#print &#39;recipBasisDeltas: %s&#39; % ( recipBasisDeltas,)</span>
  <span class="c">#print &#39;posDeltas: %s&#39; % ( posDeltas,)</span>
  <span class="c">#print &#39;forceDeltas: %s&#39; % ( forceDeltas,)</span>
  <span class="c">#print &#39;stressDeltas: %s&#39; % ( stressDeltas,)</span>


  <span class="c">#import matplotlib</span>
  <span class="c">#matplotlib.use(&#39;tkagg&#39;)</span>
  <span class="c">#import matplotlib.pyplot as plt</span>

  <span class="c">#fig, axes = plt.subplots( 1, 1)</span>
  <span class="c">###ax00 = axes[0,0]</span>
  <span class="c">#ax00 = axes</span>
  <span class="c">#ax00.plot( dosTotalMat[:,0], dosTotalMat[:,1], color=&#39;r&#39;, linestyle=&#39;-&#39;,</span>
  <span class="c">#  marker=None)</span>
  <span class="c">#ax00.set_xlabel(&#39;Energy, eV&#39;)</span>
  <span class="c">#ax00.set_ylabel(&#39;Number of states per unit cell&#39;)</span>
  <span class="c">#ax00.set_title(&#39;Density of states&#39;)</span>
  <span class="c">#ax00.xaxis.grid(color=&#39;lightblue&#39;, linestyle=&#39;solid&#39;)</span>
  <span class="c">#ax00.yaxis.grid(color=&#39;lightblue&#39;, linestyle=&#39;solid&#39;)</span>
  <span class="c">##plt.show()</span>


  <span class="c">##fig, ax = plt.subplots()</span>
  <span class="c">##</span>
  <span class="c">##ax.plot( scmat[:,0], scmat[:,1], &#39;b-&#39;)</span>
  <span class="c">##ax.plot( calcmat[:,0], calcmat[:,1], &#39;bo&#39;)</span>
  <span class="c">##ax.set_ylim( calcmat[-1,1] - 5, calcmat[-1,1] + 5)</span>
  <span class="c">##ax.xaxis.grid(color=&#39;lightblue&#39;, linestyle=&#39;solid&#39;)</span>
  <span class="c">##ax.yaxis.grid(color=&#39;lightblue&#39;, linestyle=&#39;solid&#39;)</span>
  <span class="c">##</span>
  <span class="c">##savefig(&#39;tempa.png&#39;, dpi=100, orientation=&#39;landscape&#39;, papertype=&#39;letter&#39;)</span>
  <span class="c">##</span>
  <span class="c">##plt.show()</span>


  <span class="c">#tnodes = root.findall(&#39;calculation[last()]&#39;)</span>
  <span class="c">#printNode( tnodes[0], 0, 1)</span>

  <span class="c">#tnodes = root.findall(&#39;calculation[last()]/eigenvalues&#39;)</span>
  <span class="c">#printNode( tnodes[0], 0, 1)</span>

  <span class="c">#tnodes = root.findall(&#39;calculation[last()]/eigenvalues/array&#39;)</span>
  <span class="c">#printNode( tnodes[0], 0, 1)</span>

  <span class="c">#res = getArrayByPath(</span>
  <span class="c">#  bugLev, root, &#39;calculation[last()]/eigenvalues/array&#39;)</span>
  <span class="c">#print &#39;\ncalculation[last()]/eigenvalues:\n%s&#39; % (res,)</span>

  <span class="c">#print &#39;\n&#39;</span>

<span class="c">#====================================================================</span>

</div>
<div class="viewcode-block" id="printNode"><a class="viewcode-back" href="../../nrelmatdb/ScanXml.html#nrelmat.ScanXml.printNode">[docs]</a><span class="k">def</span> <span class="nf">printNode</span><span class="p">(</span> <span class="n">node</span><span class="p">,</span> <span class="n">curLev</span><span class="p">,</span> <span class="n">maxLev</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Recursively prints an XML tree, given an xml.etree.cElementTree node.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * node (xml.etree.ElementTree.Element): The root of the XML tree.</span>
<span class="sd">  * curLev (int): The current recursion level.  Starts at 0 and</span>
<span class="sd">    is incremented for each recursive call.</span>
<span class="sd">  * maxLev (int): The max number of levels to print</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * None</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="k">if</span> <span class="n">curLev</span> <span class="o">&lt;=</span> <span class="n">maxLev</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tail</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="n">tail</span> <span class="o">=</span> <span class="s">&#39;None&#39;</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">tail</span> <span class="o">=</span> <span class="s">&#39;&quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">strip</span><span class="p">(),)</span>

    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="n">text</span> <span class="o">=</span> <span class="s">&#39;None&#39;</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">text</span> <span class="o">=</span> <span class="s">&#39;&quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">(),)</span>

    <span class="k">print</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">tag: </span><span class="si">%s</span><span class="s">  attrib: </span><span class="si">%s</span><span class="s">  tail: </span><span class="si">%s</span><span class="s">  text: </span><span class="si">%s</span><span class="s">&#39;</span> \
      <span class="o">%</span> <span class="p">(</span><span class="n">curLev</span> <span class="o">*</span> <span class="s">&#39;  &#39;</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">text</span><span class="p">,)</span>

    <span class="k">for</span> <span class="n">kid</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
      <span class="n">printNode</span><span class="p">(</span> <span class="n">kid</span><span class="p">,</span> <span class="n">curLev</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxLev</span><span class="p">)</span>

<span class="c">#====================================================================</span>
</div>
<div class="viewcode-block" id="parseText"><a class="viewcode-back" href="../../nrelmatdb/ScanXml.html#nrelmat.ScanXml.parseText">[docs]</a><span class="k">def</span> <span class="nf">parseText</span><span class="p">(</span> <span class="n">path</span><span class="p">,</span> <span class="n">nmin</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Splits ``text`` into tokens, and converts each token to ``dtype``.</span>

<span class="sd">  Called by getVec, getRawArray.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * path (str): the XML tree path to the current node, for error msgs.</span>
<span class="sd">  * nmin (int): the minimum num tokens.  If fewer are found, throwerr.</span>
<span class="sd">  * nmax (int): the maximum num tokens.  If more are found, throwerr.</span>
<span class="sd">  * dtype (python type): Either int, float, or str: the tokens</span>
<span class="sd">    are converted to dtype.</span>
<span class="sd">  * text (str): the text string to be split.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * list of tokens each having type = dtype.</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">toks</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
  <span class="n">ntok</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">toks</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ntok</span> <span class="o">&lt;</span> <span class="n">nmin</span><span class="p">:</span>
    <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;ntok &lt; nmin for path: &quot;</span><span class="si">%s</span><span class="s">&quot;  text: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">text</span><span class="p">,))</span>
  <span class="k">if</span> <span class="n">nmax</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ntok</span> <span class="o">&gt;</span> <span class="n">nmax</span><span class="p">:</span>
    <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;ntok &gt; nmax for path: &quot;</span><span class="si">%s</span><span class="s">&quot;  text: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">text</span><span class="p">,))</span>

  <span class="n">vals</span> <span class="o">=</span> <span class="n">ntok</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntok</span><span class="p">):</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">toks</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
      <span class="n">tok</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
      <span class="k">if</span> <span class="n">tok</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;false&#39;</span><span class="p">,</span> <span class="s">&#39;.false.&#39;</span><span class="p">]:</span> <span class="n">val</span> <span class="o">=</span> <span class="bp">False</span>
      <span class="k">elif</span> <span class="n">tok</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;t&#39;</span><span class="p">,</span> <span class="s">&#39;true&#39;</span><span class="p">,</span> <span class="s">&#39;.true.&#39;</span><span class="p">]:</span> <span class="n">val</span> <span class="o">=</span> <span class="bp">True</span>
      <span class="k">else</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;invalid bool in path: &quot;</span><span class="si">%s</span><span class="s">&quot;  text: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">text</span><span class="p">,))</span>
    <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span> <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">tok</span><span class="p">)</span>
      <span class="k">except</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span>
        <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;invalid int in path: &quot;</span><span class="si">%s</span><span class="s">&quot;  text: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">text</span><span class="p">,))</span>
    <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span> <span class="n">val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span> <span class="n">tok</span><span class="p">)</span>
      <span class="k">except</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span>
        <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;invalid float in path: &quot;</span><span class="si">%s</span><span class="s">&quot;  text: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">text</span><span class="p">,))</span>
    <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span> <span class="n">val</span> <span class="o">=</span> <span class="n">tok</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;unknown dtype for path: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,))</span>
    <span class="n">vals</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
  <span class="k">return</span> <span class="n">vals</span>


<span class="c">#====================================================================</span>
</div>
<div class="viewcode-block" id="getVec"><a class="viewcode-back" href="../../nrelmatdb/ScanXml.html#nrelmat.ScanXml.getVec">[docs]</a><span class="k">def</span> <span class="nf">getVec</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">nmin</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Gets text at the specified XML path, splits, and converts tokens ``dtype``.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * root (xml.etree.ElementTree.Element): The current XML node.</span>
<span class="sd">  * path (str): the XML path from the current node.</span>
<span class="sd">  * nmin (int): the minimum num tokens.  If fewer are found, throwerr.</span>
<span class="sd">  * nmax (int): the maximum num tokens.  If more are found, throwerr.</span>
<span class="sd">  * dtype (python type): Either int, float, or str: the tokens</span>
<span class="sd">    are converted to dtype.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * list of tokens each having type = dtype.</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">text</span> <span class="o">=</span> <span class="n">getString</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
  <span class="n">vals</span> <span class="o">=</span> <span class="n">parseText</span><span class="p">(</span> <span class="n">path</span><span class="p">,</span> <span class="n">nmin</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">vals</span>

<span class="c">#====================================================================</span>

<span class="c"># Return stripped string</span>
</div>
<div class="viewcode-block" id="getString"><a class="viewcode-back" href="../../nrelmatdb/ScanXml.html#nrelmat.ScanXml.getString">[docs]</a><span class="k">def</span> <span class="nf">getString</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Gets text at the specified XML path, insures there&#39;s just 1, and returns it.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * root (xml.etree.ElementTree.Element): The current XML node.</span>
<span class="sd">  * path (str): the XML path from the current node.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * stripped string.</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">lst</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span> <span class="n">path</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;path not found: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,))</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;multiple matches for path: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,))</span>
  <span class="n">ele</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">text</span> <span class="o">=</span> <span class="n">ele</span><span class="o">.</span><span class="n">text</span>
  <span class="k">return</span> <span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

<span class="c">#====================================================================</span>
</div>
<div class="viewcode-block" id="getScalar"><a class="viewcode-back" href="../../nrelmatdb/ScanXml.html#nrelmat.ScanXml.getScalar">[docs]</a><span class="k">def</span> <span class="nf">getScalar</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Gets text at the specified XML path, and converts it to ``dtype``.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * root (xml.etree.ElementTree.Element): The current XML node.</span>
<span class="sd">  * path (str): the XML path from the current node.</span>
<span class="sd">  * dtype (python type): Either int, float, or str: the token</span>
<span class="sd">    is converted to dtype.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * item having type = dtype.</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">lst</span> <span class="o">=</span> <span class="n">getVec</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c">#====================================================================</span>
</div>
<div class="viewcode-block" id="getRawArray"><a class="viewcode-back" href="../../nrelmatdb/ScanXml.html#nrelmat.ScanXml.getRawArray">[docs]</a><span class="k">def</span> <span class="nf">getRawArray</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Gets text at the specified XML path, and converts to a</span>
<span class="sd">  2D numpy array of ``dtype``.</span>

<span class="sd">  The text must be organized as one text element per row.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * root (xml.etree.ElementTree.Element): The current XML node.</span>
<span class="sd">  * path (str): the XML path from the current node.</span>
<span class="sd">  * nrow (int): the number of rows.  If 0, allow any number.</span>
<span class="sd">  * ncol (int): the number of columns.  If 0, allow any number.</span>
<span class="sd">  * dtype (python type): Either int, float, or str: the tokens</span>
<span class="sd">    are converted to dtype.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * A regular 2-dimensional numpy array of dtype.</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">lst</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span> <span class="n">path</span><span class="p">)</span>
  <span class="n">nlst</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">lst</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nlst</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;path not found: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,))</span>
  <span class="k">if</span> <span class="n">nrow</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nlst</span> <span class="o">!=</span> <span class="n">nrow</span><span class="p">:</span>
    <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;nrow mismatch for path: &quot;</span><span class="si">%s</span><span class="s">&quot;.  expected: </span><span class="si">%d</span><span class="s">  found: </span><span class="si">%d</span><span class="s">&#39;</span> \
      <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">nlst</span><span class="p">,))</span>

  <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlst</span><span class="p">):</span>

    <span class="n">ele</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">ele</span><span class="o">.</span><span class="n">text</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">parseText</span><span class="p">(</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">ncolActual</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">vals</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ncolActual</span><span class="p">:</span>
      <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;irregular array for path: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">ncol</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ncolActual</span> <span class="o">!=</span> <span class="n">ncol</span><span class="p">:</span>
      <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;ncol mismatch path: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,))</span>
    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">vals</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">rows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">rows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;unknown dtype for path: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,))</span>

  <span class="k">return</span> <span class="n">amat</span>


<span class="c">#====================================================================</span>
</div>
<div class="viewcode-block" id="getArrayByPath"><a class="viewcode-back" href="../../nrelmatdb/ScanXml.html#nrelmat.ScanXml.getArrayByPath">[docs]</a><span class="k">def</span> <span class="nf">getArrayByPath</span><span class="p">(</span> <span class="n">bugLev</span><span class="p">,</span> <span class="n">baseNode</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Converts an XML ``&lt;array&gt;`` element in vasprun.xml</span>
<span class="sd">  to a map with an array.</span>

<span class="sd">  See :func:`getArrayByNode` for details.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * bugLev (int): Debug level.  Normally 0.</span>
<span class="sd">  * baseNode (xml.etree.ElementTree.Element): current XML node</span>
<span class="sd">  * path (str): XML path from baseNode for the ``&lt;array&gt;`` element.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * A Python array</span>
<span class="sd">  &#39;&#39;&#39;</span>


  <span class="n">arrNodes</span> <span class="o">=</span> <span class="n">baseNode</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span> <span class="n">path</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrNodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;path not found: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,))</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">getArrayByNode</span><span class="p">(</span> <span class="n">bugLev</span><span class="p">,</span> <span class="n">arrNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">res</span>

<span class="c">#====================================================================</span>


<span class="c"># Returns Mrr == map containing array, like:</span>
<span class="c">#   atomMrr:</span>
<span class="c">#     _dimLens: [6]</span>
<span class="c">#     _dimNames: [&#39;ion&#39;]</span>
<span class="c">#     _fieldNames: [&#39;element&#39;, &#39;atomtype&#39;]</span>
<span class="c">#     _fieldTypes: [&#39;s&#39;, &#39;i&#39;]</span>
<span class="c">#     element: [&#39;Mo&#39; &#39;Mo&#39; &#39;S&#39; &#39;S&#39; &#39;S&#39; &#39;S&#39;]</span>
<span class="c">#     atomtype: [1 1 2 2 2 2]</span>
</div>
<div class="viewcode-block" id="getArrayByNode"><a class="viewcode-back" href="../../nrelmatdb/ScanXml.html#nrelmat.ScanXml.getArrayByNode">[docs]</a><span class="k">def</span> <span class="nf">getArrayByNode</span><span class="p">(</span> <span class="n">bugLev</span><span class="p">,</span> <span class="n">arrNode</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Converts an XML ``&lt;array&gt;`` element in vasprun.xml</span>
<span class="sd">  to a map with an array.</span>

<span class="sd">  Calls getArraySub to extract each field.</span>
<span class="sd">  The output Python map has the following structure:</span>

<span class="sd">  =============   ========================================================</span>
<span class="sd">  key             value</span>
<span class="sd">  =============   ========================================================</span>
<span class="sd">  _dimLens        numpy vec of dimension lengths.</span>
<span class="sd">                  len( dimLens) == n == numDimensions.</span>
<span class="sd">  _dimNames       numpy vec of dimension names.</span>
<span class="sd">                  len( dimLens) == n == numDimensions.</span>
<span class="sd">  _fieldNames     numpy vec of field names in the parallel arrays.</span>
<span class="sd">                  len( fieldNames) == numVariables.</span>
<span class="sd">  _fieldTypes     numpy vec of field types in the parallel arrays.</span>
<span class="sd">                  len( fieldTypes) == numVariables.</span>
<span class="sd">                  The types are: &#39;i&#39;: int, &#39;f&#39;: float, &#39;s&#39;: str</span>

<span class="sd">  &lt;fieldName&gt;     numpy n-dimensional array of the field &lt;fieldName&gt;</span>
<span class="sd">  &lt;fieldName&gt;     numpy n-dimensional array of the field &lt;fieldName&gt;</span>
<span class="sd">  &lt;fieldName&gt;     numpy n-dimensional array of the field &lt;fieldName&gt;</span>
<span class="sd">  ...</span>
<span class="sd">  =============   ========================================================</span>

<span class="sd">  Example XML for a 1-dimensional array with 2 fields: ::</span>

<span class="sd">    &lt;array name=&quot;atoms&quot; &gt;</span>
<span class="sd">     &lt;dimension dim=&quot;1&quot;&gt;ion&lt;/dimension&gt;</span>
<span class="sd">     &lt;field type=&quot;string&quot;&gt;element&lt;/field&gt;</span>
<span class="sd">     &lt;field type=&quot;int&quot;&gt;atomtype&lt;/field&gt;</span>
<span class="sd">     &lt;set&gt;</span>
<span class="sd">      &lt;rc&gt;&lt;c&gt;C &lt;/c&gt;&lt;c&gt;   1&lt;/c&gt;&lt;/rc&gt;</span>
<span class="sd">      &lt;rc&gt;&lt;c&gt;Fe&lt;/c&gt;&lt;c&gt;   2&lt;/c&gt;&lt;/rc&gt;</span>
<span class="sd">      &lt;rc&gt;&lt;c&gt;Fe&lt;/c&gt;&lt;c&gt;   2&lt;/c&gt;&lt;/rc&gt;</span>
<span class="sd">      &lt;rc&gt;&lt;c&gt;Fe&lt;/c&gt;&lt;c&gt;   2&lt;/c&gt;&lt;/rc&gt;</span>
<span class="sd">      &lt;rc&gt;&lt;c&gt;Fe&lt;/c&gt;&lt;c&gt;   2&lt;/c&gt;&lt;/rc&gt;</span>
<span class="sd">     &lt;/set&gt;</span>
<span class="sd">    &lt;/array&gt;</span>

<span class="sd">  Example resulting map: ::</span>

<span class="sd">    _dimLens: [5]</span>
<span class="sd">    _dimNames: [&#39;ion&#39;]</span>
<span class="sd">    _fieldNames: [&#39;element&#39; &#39;atomtype&#39;]</span>
<span class="sd">    _fieldTypes: [&#39;s&#39; &#39;i&#39;]</span>
<span class="sd">    element: [&#39;C&#39; &#39;Fe&#39; &#39;Fe&#39; &#39;Fe&#39; &#39;Fe&#39;]</span>
<span class="sd">    atomtype: [1 2 2 2 2]</span>

<span class="sd">  Multiple dimension arrays also are supported.</span>

<span class="sd">  The vasprun.xml handling of dimensions is unusual.</span>
<span class="sd">  What they claim is ``dim=&quot;1&quot;`` actually is the least</span>
<span class="sd">  significant dimension and varies fastest, both</span>
<span class="sd">  in the XML data and in our resulting Python array.</span>

<span class="sd">  So the XML ``&lt;dimension dim=&quot;1&quot;&gt;band&lt;/dimension&gt;``</span>
<span class="sd">  becomes the last dimension in the resulting Python array.</span>

<span class="sd">  Example XML for a 3 dimensional array with 2 fields: ::</span>

<span class="sd">    &lt;array&gt;</span>
<span class="sd">     &lt;dimension dim=&quot;1&quot;&gt;band&lt;/dimension&gt;</span>
<span class="sd">     &lt;dimension dim=&quot;2&quot;&gt;kpoint&lt;/dimension&gt;</span>
<span class="sd">     &lt;dimension dim=&quot;3&quot;&gt;spin&lt;/dimension&gt;</span>
<span class="sd">     &lt;field&gt;eigene&lt;/field&gt;</span>
<span class="sd">     &lt;field&gt;occ&lt;/field&gt;</span>
<span class="sd">     &lt;set&gt;</span>
<span class="sd">      &lt;set comment=&quot;spin 1&quot;&gt;</span>
<span class="sd">       &lt;set comment=&quot;kpoint 1&quot;&gt;</span>
<span class="sd">        &lt;r&gt;   -6.5058    1.0000 &lt;/r&gt;</span>
<span class="sd">        &lt;r&gt;    0.2537    1.0000 &lt;/r&gt;</span>
<span class="sd">        &lt;r&gt;    0.7101    1.0000 &lt;/r&gt;</span>
<span class="sd">        ...</span>
<span class="sd">        &lt;r&gt;    8.1390    0.0000 &lt;/r&gt;</span>
<span class="sd">       &lt;/set&gt;</span>
<span class="sd">       &lt;set comment=&quot;kpoint 2&quot;&gt;</span>
<span class="sd">        &lt;r&gt;   -6.3718    1.0000 &lt;/r&gt;</span>
<span class="sd">        &lt;r&gt;   -0.0841    1.0000 &lt;/r&gt;</span>
<span class="sd">        &lt;r&gt;    0.7508    1.0000 &lt;/r&gt;</span>
<span class="sd">       ...</span>
<span class="sd">       &lt;/set&gt;</span>
<span class="sd">       &lt;set comment=&quot;kpoint 101&quot;&gt;</span>
<span class="sd">        &lt;r&gt;   -5.8567    1.0000 &lt;/r&gt;</span>
<span class="sd">        &lt;r&gt;   -0.0854    1.0000 &lt;/r&gt;</span>
<span class="sd">        &lt;r&gt;    0.9602    1.0000 &lt;/r&gt;</span>
<span class="sd">        &lt;r&gt;    7.7174    0.0000 &lt;/r&gt;</span>
<span class="sd">        &lt;r&gt;    7.8556    0.0000 &lt;/r&gt;</span>
<span class="sd">       &lt;/set&gt;</span>
<span class="sd">      &lt;/set&gt;</span>
<span class="sd">     &lt;/set&gt;</span>
<span class="sd">    &lt;/array&gt;</span>

<span class="sd">  Example resulting map: ::</span>

<span class="sd">    _dimLens: [  1 101  22]</span>
<span class="sd">    _dimNames: [&#39;spin&#39; &#39;kpoint&#39; &#39;band&#39;]</span>
<span class="sd">    _fieldNames: [&#39;eigene&#39; &#39;occ&#39;]</span>
<span class="sd">    _fieldTypes: [&#39;f&#39; &#39;f&#39;]</span>
<span class="sd">    eigene: [[[-6.5058  0.2537  0.7101 ...,  7.6096  7.8817  8.139 ]</span>
<span class="sd">        [-6.3718 -0.0841  0.7508 ...,  7.481   7.8491  7.9595]</span>
<span class="sd">        [-6.1332 -0.611   1.0672 ...,  7.0857  7.8655  7.9314]</span>
<span class="sd">        ...,</span>
<span class="sd">        [-5.8462  0.3687  0.9498 ...,  7.1721  7.4739  7.6631]</span>
<span class="sd">        [-5.8016  0.5503  0.5886 ...,  7.4113  7.5794  7.7332]</span>
<span class="sd">        [-5.8567 -0.0854  0.9602 ...,  7.2729  7.7174  7.8556]]]</span>
<span class="sd">    occ: [[[ 1.      1.      1.     ...,  0.      0.      0.    ]</span>
<span class="sd">        [ 1.      1.      1.     ...,  0.      0.      0.    ]</span>
<span class="sd">        [ 1.      1.      1.     ...,  1.      0.      0.    ]</span>
<span class="sd">        ...,</span>
<span class="sd">        [ 1.      1.      1.     ...,  1.      0.      0.    ]</span>
<span class="sd">        [ 1.      1.      1.     ...,  0.      0.      0.    ]</span>
<span class="sd">        [ 1.      1.      1.     ...,  0.9751  0.      0.    ]]]</span>


<span class="sd">  **Parameters**:</span>

<span class="sd">  * bugLev (int): Debug level.  Normally 0.</span>
<span class="sd">  * node (xml.etree.ElementTree.Element):</span>
<span class="sd">    The XML node for the ``&lt;array&gt;`` element.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * A Python array</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">dimNodes</span> <span class="o">=</span> <span class="n">arrNode</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;dimension&#39;</span><span class="p">)</span>
  <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">dimNodes</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;no dimensions found&#39;</span><span class="p">)</span>
  <span class="n">dimNames</span> <span class="o">=</span> <span class="p">[</span><span class="n">nd</span><span class="o">.</span><span class="n">text</span> <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">dimNodes</span><span class="p">]</span>
  <span class="n">dimNames</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>         <span class="c"># dimNames are in reverse order in XML</span>
  <span class="n">dimNames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">dimNames</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
  <span class="n">dimLens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">[</span><span class="n">ndim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

  <span class="n">fieldNodes</span> <span class="o">=</span> <span class="n">arrNode</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;field&#39;</span><span class="p">)</span>
  <span class="n">nfield</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">fieldNodes</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nfield</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;no fields found&#39;</span><span class="p">)</span>
  <span class="n">fieldNames</span> <span class="o">=</span> <span class="p">[</span><span class="n">nd</span><span class="o">.</span><span class="n">text</span> <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">fieldNodes</span><span class="p">]</span>
  <span class="n">fieldNames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">fieldNames</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>

  <span class="c"># We set fieldTypes[ifield] to max( all found types for ifield)</span>
  <span class="c"># Types are: 0:int, 1:float, 2:string</span>
  <span class="n">fieldTypes</span> <span class="o">=</span> <span class="n">nfield</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="n">setNodes</span> <span class="o">=</span> <span class="n">arrNode</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;set&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">setNodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;wrong len for primary set&#39;</span><span class="p">)</span>
  <span class="n">setNode</span> <span class="o">=</span> <span class="n">setNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">resList</span> <span class="o">=</span> <span class="n">nfield</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">ifield</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nfield</span><span class="p">):</span>
    <span class="n">amat</span> <span class="o">=</span> <span class="n">getArraySub</span><span class="p">(</span>
      <span class="n">bugLev</span><span class="p">,</span>
      <span class="n">setNode</span><span class="p">,</span>
      <span class="n">ifield</span><span class="p">,</span>
      <span class="n">fieldTypes</span><span class="p">,</span>
      <span class="mi">0</span><span class="p">,</span>            <span class="c"># idim</span>
      <span class="n">dimLens</span><span class="p">)</span>

    <span class="c"># Convert all elements of each field ifield to fieldTypes[ifield].</span>
    <span class="k">if</span>   <span class="n">fieldTypes</span><span class="p">[</span><span class="n">ifield</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">amat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fieldTypes</span><span class="p">[</span><span class="n">ifield</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">amat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fieldTypes</span><span class="p">[</span><span class="n">ifield</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="n">amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">amat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;unknown fieldType&#39;</span><span class="p">)</span>

    <span class="n">resList</span><span class="p">[</span><span class="n">ifield</span><span class="p">]</span> <span class="o">=</span> <span class="n">amat</span>

  <span class="c"># Convert fieldTypes from 0,1,2 to &#39;i&#39;, &#39;f&#39;, &#39;s&#39;</span>
  <span class="n">fldMap</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">:</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="s">&#39;s&#39;</span><span class="p">}</span>
  <span class="n">fieldTypeStgs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">fldMap</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">fieldTypes</span><span class="p">)</span>
  <span class="n">fieldTypeStgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">fieldTypeStgs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>

  <span class="n">resMap</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;_dimNames&#39;</span><span class="p">:</span> <span class="n">dimNames</span><span class="p">,</span>
    <span class="s">&#39;_dimLens&#39;</span><span class="p">:</span> <span class="n">dimLens</span><span class="p">,</span>
    <span class="s">&#39;_fieldNames&#39;</span><span class="p">:</span> <span class="n">fieldNames</span><span class="p">,</span>
    <span class="s">&#39;_fieldTypes&#39;</span><span class="p">:</span> <span class="n">fieldTypeStgs</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fieldNames</span><span class="p">)):</span>
    <span class="n">ar</span> <span class="o">=</span> <span class="n">resList</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">ar</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dimLens</span><span class="p">)):</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;dimLens mismatch&#39;</span><span class="p">)</span>
    <span class="n">resMap</span><span class="p">[</span><span class="n">fieldNames</span><span class="p">[</span><span class="n">ii</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ar</span>

  <span class="k">return</span> <span class="n">resMap</span>


<span class="c">#====================================================================</span>

</div>
<div class="viewcode-block" id="getArraySub"><a class="viewcode-back" href="../../nrelmatdb/ScanXml.html#nrelmat.ScanXml.getArraySub">[docs]</a><span class="k">def</span> <span class="nf">getArraySub</span><span class="p">(</span>
  <span class="n">bugLev</span><span class="p">,</span>
  <span class="n">setNode</span><span class="p">,</span>
  <span class="n">ifield</span><span class="p">,</span>
  <span class="n">fieldTypes</span><span class="p">,</span>
  <span class="n">idim</span><span class="p">,</span>
  <span class="n">dimLens</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Decodes the XML for one field (one variable) for an</span>
<span class="sd">  ``&lt;array&gt;``.</span>

<span class="sd">  Called by getArrayByNode.  See :func:`getArrayByNode` for details.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * bugLev (int): Debug level.  Normally 0.</span>
<span class="sd">  * setNode (xml.etree.ElementTree.Element): the element for ``&lt;set&gt;``.</span>
<span class="sd">  * ifield (int): the index number of the field.</span>
<span class="sd">  * fieldTypes (int[]): the numeric field types so far.</span>
<span class="sd">    The numeric types are: 0: int, 1: float, 2: str.</span>
<span class="sd">    We take the max of the field types.</span>
<span class="sd">  * tp (Python type): The desired type.</span>
<span class="sd">  * idim (int): dimension number == recursion level == array nest level.</span>
<span class="sd">    0 on the first call, 1 for the next level array, etc.</span>
<span class="sd">  * dimLens (int[]): list of dimension lengths.  Updated.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * A Python array with elements of type str.</span>
<span class="sd">    The caller converts them to the correct type.</span>
<span class="sd">  &#39;&#39;&#39;</span>


  <span class="n">nfield</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fieldTypes</span><span class="p">)</span>
  <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimLens</span><span class="p">)</span>

  <span class="c"># If we&#39;re at the last dimension, decode the element values.</span>
  <span class="k">if</span> <span class="n">idim</span> <span class="o">==</span> <span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
    <span class="c"># Try long form:</span>
    <span class="c">#   &lt;set&gt;</span>
    <span class="c">#     &lt;rc&gt;</span>
    <span class="c">#       &lt;c&gt;2&lt;/c&gt;</span>
    <span class="c">#       &lt;c&gt;Mo&lt;/c&gt;</span>
    <span class="n">rcNodes</span> <span class="o">=</span> <span class="n">setNode</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;rc&#39;</span><span class="p">)</span>     <span class="c"># long form: &lt;rc&gt; &lt;c&gt;</span>

    <span class="c"># Try short form:</span>
    <span class="c">#   &lt;set comment=&#39;spin 1&#39;&gt;</span>
    <span class="c">#     &lt;set comment=&#39;kpoint 1&#39;&gt;</span>
    <span class="c">#       &lt;r&gt;-30.3711 1.0000&lt;/r&gt;</span>
    <span class="c">#       &lt;r&gt;-30.3709 1.0000&lt;/r&gt;</span>
    <span class="n">rNodes</span> <span class="o">=</span> <span class="n">setNode</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;r&#39;</span><span class="p">)</span>       <span class="c"># short form: &lt;r&gt;</span>

    <span class="n">nval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">rcNodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span> <span class="n">rNodes</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">dimLens</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">dimLens</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span> <span class="o">=</span> <span class="n">nval</span>
    <span class="k">if</span> <span class="n">nval</span> <span class="o">!=</span> <span class="n">dimLens</span><span class="p">[</span><span class="n">idim</span><span class="p">]:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;irregular array&#39;</span><span class="p">)</span>
    <span class="n">resVec</span> <span class="o">=</span> <span class="n">nval</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rcNodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>                <span class="c"># long form: &lt;rc&gt; &lt;c&gt;</span>
      <span class="k">for</span> <span class="n">ival</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nval</span><span class="p">):</span>
        <span class="n">cNodes</span> <span class="o">=</span> <span class="n">rcNodes</span><span class="p">[</span><span class="n">ival</span><span class="p">]</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cNodes</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nfield</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;wrong num fields&#39;</span><span class="p">)</span>
        <span class="n">stg</span> <span class="o">=</span> <span class="n">cNodes</span><span class="p">[</span><span class="n">ifield</span><span class="p">]</span><span class="o">.</span><span class="n">text</span>
        <span class="n">resVec</span><span class="p">[</span><span class="n">ival</span><span class="p">]</span> <span class="o">=</span> <span class="n">stg</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rNodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>               <span class="c"># short form: &lt;r&gt;</span>
      <span class="k">for</span> <span class="n">ival</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nval</span><span class="p">):</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="n">rNodes</span><span class="p">[</span><span class="n">ival</span><span class="p">]</span><span class="o">.</span><span class="n">text</span>
        <span class="n">toks</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">toks</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nfield</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;wrong num fields&#39;</span><span class="p">)</span>
        <span class="n">resVec</span><span class="p">[</span><span class="n">ival</span><span class="p">]</span> <span class="o">=</span> <span class="n">toks</span><span class="p">[</span><span class="n">ifield</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;unknown array structure&#39;</span><span class="p">)</span>

    <span class="c"># Strip all strings.</span>
    <span class="c"># Set fieldTypes[ifield] to max( current type, all found types)</span>
    <span class="c"># Types are: 0:int, 1:float, 2:string</span>
    <span class="k">for</span> <span class="n">ival</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nval</span><span class="p">):</span>
      <span class="n">resVec</span><span class="p">[</span><span class="n">ival</span><span class="p">]</span> <span class="o">=</span> <span class="n">resVec</span><span class="p">[</span><span class="n">ival</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
      <span class="n">stg</span> <span class="o">=</span> <span class="n">resVec</span><span class="p">[</span><span class="n">ival</span><span class="p">]</span>
      <span class="n">ftype</span> <span class="o">=</span> <span class="mi">2</span>            <span class="c"># assume worst case: string</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="nb">float</span><span class="p">(</span> <span class="n">stg</span><span class="p">)</span>
        <span class="n">ftype</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="k">pass</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="nb">int</span><span class="p">(</span> <span class="n">stg</span><span class="p">)</span>
        <span class="n">ftype</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="k">pass</span>
      <span class="n">fieldTypes</span><span class="p">[</span><span class="n">ifield</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">fieldTypes</span><span class="p">[</span><span class="n">ifield</span><span class="p">],</span> <span class="n">ftype</span><span class="p">)</span>


  <span class="k">else</span><span class="p">:</span>    <span class="c"># else idim &lt; ndim - 1.  Recursion.</span>
    <span class="n">setNodes</span> <span class="o">=</span> <span class="n">setNode</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;set&#39;</span><span class="p">)</span>
    <span class="n">nset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">setNodes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dimLens</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">dimLens</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span> <span class="o">=</span> <span class="n">nset</span>
    <span class="k">if</span> <span class="n">nset</span> <span class="o">!=</span> <span class="n">dimLens</span><span class="p">[</span><span class="n">idim</span><span class="p">]:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;irregular array&#39;</span><span class="p">)</span>
    <span class="n">resVec</span> <span class="o">=</span> <span class="n">nset</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">iset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nset</span><span class="p">):</span>
      <span class="n">resVec</span><span class="p">[</span><span class="n">iset</span><span class="p">]</span> <span class="o">=</span> <span class="n">getArraySub</span><span class="p">(</span>          <span class="c"># recursion</span>
        <span class="n">bugLev</span><span class="p">,</span>
        <span class="n">setNodes</span><span class="p">[</span><span class="n">iset</span><span class="p">],</span>
        <span class="n">ifield</span><span class="p">,</span>
        <span class="n">fieldTypes</span><span class="p">,</span>
        <span class="n">idim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">dimLens</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">resVec</span>
 

<span class="c">#====================================================================</span>

<span class="c"># Not used</span>
</div>
<span class="k">def</span> <span class="nf">convertTypesUnused</span><span class="p">(</span> <span class="n">tp</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Recursively converts the elements of an array ``vec``</span>
<span class="sd">  from str to the specified type.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * tp (Python type): The desired type.</span>
<span class="sd">  * vec (str[] or str[][] or ...): the array to be converted.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * A Python array with elements of type ``tp``.</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vec</span><span class="p">)):</span>
      <span class="n">vec</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">tp</span><span class="p">(</span> <span class="n">vec</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">subVec</span> <span class="ow">in</span> <span class="n">vec</span><span class="p">:</span>
      <span class="n">convertTypes</span><span class="p">(</span> <span class="n">tp</span><span class="p">,</span> <span class="n">subVec</span><span class="p">)</span>             <span class="c"># recursion</span>
  <span class="k">else</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;unknown array structure&#39;</span><span class="p">)</span>

<span class="c">#====================================================================</span>


<div class="viewcode-block" id="maxAbsDiff"><a class="viewcode-back" href="../../nrelmatdb/ScanXml.html#nrelmat.ScanXml.maxAbsDiff">[docs]</a><span class="k">def</span> <span class="nf">maxAbsDiff</span><span class="p">(</span> <span class="n">mata</span><span class="p">,</span> <span class="n">matb</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Returns the max abs diff between two 2D numpy matrices.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * mata (numpy 2D array): Array to be compared.</span>
<span class="sd">  * matb (numpy 2D array): Array to be compared.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * float scalar: max_i( max_j( abs( mata[i][j] - matb[i][j]))</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="p">(</span><span class="n">nrow</span><span class="p">,</span><span class="n">ncol</span><span class="p">)</span> <span class="o">=</span> <span class="n">mata</span><span class="o">.</span><span class="n">shape</span>
  <span class="k">if</span> <span class="n">matb</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">mata</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;maxAbsDiff: shape mismatch&#39;</span><span class="p">)</span>
  <span class="n">diffMat</span> <span class="o">=</span>  <span class="nb">abs</span><span class="p">(</span> <span class="n">matb</span> <span class="o">-</span> <span class="n">mata</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="nb">map</span><span class="p">(</span> <span class="nb">max</span><span class="p">,</span> <span class="n">diffMat</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">res</span>

<span class="c">#====================================================================</span>
</div>
<div class="viewcode-block" id="calcMatDeltas"><a class="viewcode-back" href="../../nrelmatdb/ScanXml.html#nrelmat.ScanXml.calcMatDeltas">[docs]</a><span class="k">def</span> <span class="nf">calcMatDeltas</span><span class="p">(</span> <span class="n">mats</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Returns the max abs diffs between adjacent pairs of a</span>
<span class="sd">  list of 2D numpy matrices.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * mats (list of 2D numpy matrices)</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * deltas (float[]): deltas[k] = maxAbsDiff( mats[k-1], mats[k])</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">nmat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">mats</span><span class="p">)</span>
  <span class="n">deltas</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nmat</span><span class="p">):</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">maxAbsDiff</span><span class="p">(</span> <span class="n">mats</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">mats</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
    <span class="n">deltas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">delta</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">deltas</span>

<span class="c">#====================================================================</span>
</div>
<div class="viewcode-block" id="printMrr"><a class="viewcode-back" href="../../nrelmatdb/ScanXml.html#nrelmat.ScanXml.printMrr">[docs]</a><span class="k">def</span> <span class="nf">printMrr</span><span class="p">(</span> <span class="n">vmap</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Prints the Mrr map returned by getArrayByPath or getArrayByNode.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * vmap (map): the MRR map</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * None</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">keys</span> <span class="o">=</span> <span class="n">vmap</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
  <span class="n">keys</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">):</span>
      <span class="n">val</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
      <span class="k">print</span> <span class="s">&#39;  </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,)</span>
  <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">vmap</span><span class="p">[</span><span class="s">&#39;_fieldNames&#39;</span><span class="p">]:</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">print</span> <span class="s">&#39;  </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,)</span>
  <span class="k">print</span> <span class="s">&#39;&#39;</span>

<span class="c">#====================================================================</span>
</div>
<div class="viewcode-block" id="throwerr"><a class="viewcode-back" href="../../nrelmatdb/ScanXml.html#nrelmat.ScanXml.throwerr">[docs]</a><span class="k">def</span> <span class="nf">throwerr</span><span class="p">(</span> <span class="n">msg</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Prints an error message and raises Exception.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * msg (str): Error message.</span>

<span class="sd">  **Returns**</span>

<span class="sd">  * (Never returns)</span>
<span class="sd">  </span>
<span class="sd">  **Raises**</span>

<span class="sd">  * Exception</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="k">print</span> <span class="n">msg</span>
  <span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="n">msg</span>
  <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span> <span class="n">msg</span><span class="p">)</span>

<span class="c">#====================================================================</span>
</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span> <span class="n">main</span><span class="p">()</span>

<span class="c">#====================================================================</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Pylada-light 1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Mayeul d&#39;Avezac.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>